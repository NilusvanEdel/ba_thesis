#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrreprt
\begin_preamble
% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\usepackage{subcaption}
\captionsetup[table]{skip=10pt}

%Kapitelzahl sehr groß
\makeatletter% siehe De-TeX-FAQ 
 \renewcommand*{\chapterformat}{% 
   \begingroup% damit \unitlength-Änderung lokal bleibt 
     \setlength{\unitlength}{1mm}% 
     \begin{picture}(10,10)(0,5) 
       \setlength{\fboxsep}{0pt} 
       %\put(0,0){\framebox(20,40){}}% 
       %\put(0,20){\makebox(20,20){\rule{20\unitlength}{20\unitlength}}}% 
       \put(10,15){\line(1,0){\dimexpr 
           \textwidth-20\unitlength\relax\@gobble}}% 
       \put(0,0){\makebox(10,20)[r]{% 
           \fontsize{28\unitlength}{28\unitlength}\selectfont\thechapter 
           \kern-.05em% Ziffer in der Zeichenzelle nach rechts schieben 
         }}% 
       \put(10,15){\makebox(\dimexpr 
           \textwidth-20\unitlength\relax\@gobble,\ht\strutbox\@gobble)[l]{% 
             \ \normalsize\color{black}\chapapp~\thechapter\autodot 
           }}% 
     \end{picture} % <-- Leerzeichen ist hier beabsichtigt! 
   \endgroup 
}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
 \IfFileExists{lmodern.sty}{\usepackage{lmodern}}
  {\usepackage[scaled=0.92]{helvet}
    \usepackage{mathptmx}
    \usepackage{courier} }
\fi

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{arabic}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
%\addto\captionsngerman{ 
%\renewcommand{\figurename}{Abb.}% 
%\renewcommand{\tablename}{Tab.}% 
%\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
%}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}
% algorithm package
\usepackage{algorithm,algpseudocode}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}
% for better tables
\usepackage{caption, booktabs}

%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
%\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
 
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 120 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Analyse und Interpretation des Risswachstums an thermisch hochbelasteten Bauteilen für die Fusionsforschung mittels IR Diagnostik und FE Modellierung"
\pdf_author "Timo Schindler"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/UniOsnabrück.GIF
	lyxscale 25
	width 7.5cm

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Fakultät Humanwissenschaften
\begin_inset space \hspace{}
\length 2.5cm
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size larger
Bachelor thesis
\end_layout

\begin_layout Standard
\noindent
\align left

\size large
Adaptive K-Means Clustering of Data Sequences
\end_layout

\begin_layout Standard
Clustering of video sequences with dynamic cluster count and recognition
 of their serial identity
\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
eingereicht von:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linus Edelkott 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Matrikelnummer: 950499
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Studiengang: Cognitive Science
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Betreuer:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MS Julius Schöning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Dr.
 Gunther Heidemann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Osnabrück, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
\lang ngerman
Declaration of authorship
\end_layout

\begin_layout Standard

\lang ngerman
I hereby certify that the work presented here is, to the best of my knowledge
 and belief, original and the result of my own investigations, except as
 acknowledged, and has not been submitted, either in part or whole, for
 a degree at this or any other university.
\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\lang ngerman
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Osnabrück, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Unterschrift
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linus Edelkott
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
chaptername}{}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Chapter
Theoretical basis
\end_layout

\begin_layout Section
Clustering
\end_layout

\begin_layout Standard
Clustering is a form of predictive modelling, it makes no difference in
 between input and output components.
 These methods in general are called 
\begin_inset Quotes gld
\end_inset

unsupervised
\begin_inset Quotes grd
\end_inset

 learning.
 The opposite would be predictive clustering, for example regression and
 classification.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Überarbeiten!
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The vague objective of clustering algorithm is to find 
\begin_inset Quotes gld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{interesting}
\end_layout

\end_inset

 groupings of training samples
\begin_inset Quotes grd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "VladimirCherkassky2007"

\end_inset

.
 This separation into a number of groups, called clusters happens according
 to a meassure of similarity.
 The goal of the algorithm is to find clusters in a way, that samples within
 are more similar to each other than samples from different clusters and
 thus minimizing the prediction error.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
possibly to preshadow intra/inter cluster distance
\end_layout

\end_inset

 Hereby the similarity meassurement reflects a priori knowledge, for example
 using standard euclidian distance on a RGB colorspace equals the assumption
 that all values have equal importance.
 Nevertheless is the clustering process usually 
\begin_inset Quotes gld
\end_inset

ad hoc
\begin_inset Quotes grd
\end_inset

, meaning that the clusters are not predefined by a priori knowledge (despite
 the similarity meassurement) and for this reason very generalisable.
 
\end_layout

\begin_layout Standard
Often clustering algorithm create prototypes, 
\begin_inset Quotes gld
\end_inset

a data object that is representative of the other objects in the cluster
\begin_inset Quotes grd
\end_inset

.
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset

These will often be used as input for further data processing or data analysis
 techniques.
\end_layout

\begin_layout Standard
One of the most common usage of clustering algorithm is dimensionality reduction.
 The goal is to find a mapping from a 
\begin_inset Formula $d-$
\end_inset

dimensional input space 
\begin_inset Formula $R^{d}$
\end_inset

to some 
\begin_inset Formula $m$
\end_inset

 dimensional output space 
\begin_inset Formula $R^{m}$
\end_inset

, where 
\begin_inset Formula $m<n$
\end_inset

.
\begin_inset CommandInset citation
LatexCommand cite
key "VladimirCherkassky2007"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
G(x):R^{d}\rightarrow R^{m}
\]

\end_inset


\end_layout

\begin_layout Standard
A good mapping should also posess the inverse function.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
F(z)=R^{m}\rightarrow R^{d}
\]

\end_inset


\end_layout

\begin_layout Standard
Hence the reduced output, can be decoded to the original input and the whole.
 Thus the main information can be kept, while the amount of data is reduced.
\end_layout

\begin_layout Standard
Clusters can either be described hierarchically (i.e.
 described in tree structures) or the can be purely partional.
 The latter sort can be further divided into 2 groups.
 The first one is called 
\begin_inset Quotes gld
\end_inset

hard clustering
\begin_inset Quotes grd
\end_inset

, each sample is definetly placed in only one cluster.
 The second one is called 
\begin_inset Quotes gld
\end_inset

soft clustering
\begin_inset Quotes grd
\end_inset

 and in alternative each sample can belong to serveral clusters according
 to a related probabilty distribution.
 
\begin_inset CommandInset citation
LatexCommand cite
key "Poole2010"

\end_inset


\end_layout

\begin_layout Section
K-means clustering
\end_layout

\begin_layout Standard
K-means clustering is one of the oldest and most widely used clustering
 algorithms.
 It requires an explicit distance meassure, an input of traning samples
 and the number of classes k.
 It belongs to the class of hard clustering algorithms.
\begin_inset CommandInset citation
LatexCommand cite
key "Poole2010"

\end_inset

 
\end_layout

\begin_layout Standard
The main concept is to represent each cluster by the vector of mean attribute
 values for numeric attributes or by a vector of the most frequent values
 for nominal attributes, that are assigned to that cluster.
 This representation is also called cluster center and acts as a prototype.
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset


\end_layout

\begin_layout Standard
The operation of k-means clustering starts with initializing random points
 and assigning them as starting points for a cluster, this will be repeated
 until the desired number of clusters is generated.
 The next step is to asssign every training sample to the closest clustercenter
 and update it according to the mean of all clustermembers for each attribute.
 This has to be repeated until it converges, due to bad initialiation points
 this might never be achieved.
 Hence the usual implementation either uses a limit for the number of iterations
 or stops if the number of changes fall below a certain 
\begin_inset Formula $\epsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {select K points as initial centroids}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat {}
\end_layout

\begin_layout Plain Layout


\backslash
State {assign each data sample to the closest center}
\end_layout

\begin_layout Plain Layout


\backslash
State {update the clustercenters by shifting them to the mean of each attribute}
\end_layout

\begin_layout Plain Layout


\backslash
Until {centroids moved no more than $
\backslash
epsilon$}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Basic K-means algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The k-means algorithm aims to minimize an objective squared error function:
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
J=\sum_{j=1}^{k}\sum_{\forall i}|x_{i}^{j}-c_{j}|^{2}
\]

\end_inset

, hereby 
\begin_inset Formula $c_{k}$
\end_inset

is the coordinate vector of the 
\begin_inset Formula $j$
\end_inset

th cluster and 
\begin_inset Formula $\{x_{i}^{j}\}$
\end_inset

 are the points assigned to the 
\begin_inset Formula $j$
\end_inset

th cluster.
 The distance meassure can be chosen dependent on the task, but most of
 the times the normal euclidian distance is used.
 
\end_layout

\begin_layout Standard
One advange of k-means clustering is its low complexity but it has a weakness
 in the requirement of getting an accurate number of clusters as input a
 priori.
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Bora2015"

\end_inset


\end_layout

\begin_layout Section
K-means color segmentation
\end_layout

\begin_layout Standard
One of the many applications for the k-means clustering algorithm is colorsegmen
tation.
 Image segmentation in general is the process of splitting/ classifying
 an image into several parts, so that each region builds a homogenous segment.
 Combining any of the homogenous segments would result in a heterogenous
 segment.
\begin_inset CommandInset citation
LatexCommand cite
key "Bora2015"

\end_inset

 
\end_layout

\begin_layout Standard
Segmentation algorithms are often the very first step in image processing.
 Subsequent steps, as for example feature extraction and classification
 are highly reliant on the successful generation of homogenous parts.
 If the respective object can not be identified, it can certainly not be
 classified.
 The segmentation outcome will always be dependent on the underlying image
 and the object, or feature which should be identified.
 Thus there is no single perfect clustering for an image, this complicates
 the evaluation process.
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset


\end_layout

\begin_layout Standard
Segmentation algorithm can be divided into two main groups.
 The first one is the edge/boundary group, the associated algorithms aim
 to detect edges to find boundaries in between groups of pixels.
 The second group is region based and tries to order pixels according to
 their mutual similarity.
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset


\end_layout

\begin_layout Section
Optimal clustercount
\end_layout

\begin_layout Standard
Although the k-means clustering is relatively easy to implement on a relative
 wide field, it has some drawbacks.
 The final results of the clustering algorithm, vary depending on the number
 of clusters and especially on their initialisation.
 So if the initial clusters are chosen randomly, it will get different results.
\begin_inset CommandInset citation
LatexCommand cite
key "IMCIP-2015"

\end_inset


\end_layout

\begin_layout Standard
In order to find the optimal number of clusters and initialise them automaticall
y Siddheswar Ray and Rose H.
 Turi proposed an algorithm which uses 
\begin_inset Quotes eld
\end_inset

a simple validity measure based on the intra-cluster and inter-cluster distance
 measure
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

.
 
\end_layout

\begin_layout Standard
The basic k-means algorithm minimizes the sum of squared distanced from
 all points to their cluster centers, hence the distances from each point
 to their cluster centers provides the information whether the clusters
 are compact.
 The average of all these distance constitute the intra-cluster meassurement.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{intra}=\frac{1}{N}\sum_{i=1}^{K}\|x-z_{i}\|^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $N$
\end_inset

 is the number of all pixels, 
\begin_inset Formula $K$
\end_inset

 is the clustercount and 
\begin_inset Formula $z_{i}$
\end_inset

is the actual clustercenter.
 To be as compact as as possible, we obviously want to minimize this meassuremen
t.
 The inter-cluster meassurement in contrast describes the distances between
 the clustercenters and should be maximized.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{inter}=\min\left(\|z_{i}-z_{j}\|^{2}\right),i=1,2,...,K-1,j=i+1,...,K
\]

\end_inset


\end_layout

\begin_layout Standard
Only the minimum of each distance is considered, since we always want to
 maximize the smallest distances.
 The maximized values of larger values will be automatically bigger as well.
\end_layout

\begin_layout Standard
In an optimal clustering we obviously want to have compact clusters, which
 are as distant as possible.
 Thus the validity meassurement is defined as the ratio of the intra and
 inter meassure.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{validity}=\frac{\text{intra}}{\text{inter}}
\]

\end_inset


\end_layout

\begin_layout Standard
The optimal clustercount should posses the smallest validity.
 
\end_layout

\begin_layout Standard
The proposed algorithm of Siddheswar Ray and Rose H.
 Turi starts with initialising every single data point into one cluster
 and using the average of each attribute as clustercenter.
 Repeatedly the variance of each attribute will be calculated and added
 up, the sum of all attributed will be used as divisor.
 We take the largest value and split the cluster.
 Due to the occuring minimazation of intra-cluster distance in in k-means
 clustering, this cluster would most likely be split when increasing the
 clustercount.
 Before the process will be repeated, the normal k-means clustering will
 be executed and the validity calculated according to the new calculated
 clustercenters.
\end_layout

\begin_layout Standard
The clusters will be split, according to the old clustercenter and with
 regard to the minimum and maximum of each attribute.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{i}^{'}=\left(z_{i1}-a_{1},z_{i2}-a_{2},z_{i3}-a_{3}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{i}^{''}=\left(z_{i1}+a_{1},z_{i2}+a_{2},z_{i3}+a_{3}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $z_{i}^{'}$
\end_inset

and 
\begin_inset Formula $z_{i}^{''}$
\end_inset

being the two new cluster centers, 
\begin_inset Formula $z_{i}$
\end_inset

being the the old cluster centers with index 
\begin_inset Formula $1,2,3$
\end_inset

 for each attribute.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a_{j}=\frac{z_{ij}-\max_{j}}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\max_{j}$
\end_inset

is the maximum value for the 
\begin_inset Formula $j$
\end_inset

-component.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {Initialise a single cluster, with the average of each attribute as
 clustercenter}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat{}
\end_layout

\begin_layout Plain Layout


\backslash
State {calculate the variance of each attribute $
\backslash
sigma_{i}$ and add them up $
\backslash
sum_{i=1}^{I}
\backslash
frac{1}{I}
\backslash
sigma_{i}$ }
\end_layout

\begin_layout Plain Layout


\backslash
State {split the cluster centers with the biggest variance}
\end_layout

\begin_layout Plain Layout


\backslash
State {use the standard k-means algorithm and calculate the validity}
\end_layout

\begin_layout Plain Layout


\backslash
Until {a self appointed limit for k is reached}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Find the optimal clustercount algorithm
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the larger inter-cluster distance, small cluster numbers tend to
 be selected more often.
 In synthetic images, with an actual perfect clustercount the calculated
 minimal validity will be the optimal clustercount, but in natural images
 where a higher k is prefered the smallest validity after the first local
 maximum seems to fit better.
\end_layout

\begin_layout Standard
Important to notice is that, this algorithm is supposed for image segmentation
 in RGB-colorspace, although it can also be implemented on a different featuresp
ace as long as the attributes can be scaled properly.
\end_layout

\begin_layout Section
Colorspaces
\end_layout

\begin_layout Chapter
Assignment of Tasks
\end_layout

\begin_layout Standard
One of the logical extensions of the k-means algorithm used for colorsegmentatio
n seems to be to implement the algorithm not only on images, but on whole
 video sequences.
 The existing algorithms for determing the optimal clustercount could be
 transfered on whole videos, by simply processing them frame by frame.
 Obviously the resulting processing time would prove unfit for most practical
 use.
 While the regular k-means computing time is feasible, at least if a iterationli
mit is implemented, the computing time for dynamic clustercount identification
 is tremendous, due to the repeatet use of the basic k-means algorithm.
 
\end_layout

\begin_layout Standard
Hence the first task of this bachelor thesis is to find a way to adapt the
 identification of the optimal cluster number from images to video sequences.
 
\end_layout

\begin_layout Standard
Without further investigation the resulting cluster have only a limited
 application use and can only represent the gathered knowledge of a single
 frame.
 In order to include the information of the whole video it is necessary
 to compare the resulting clusters of each frame.
 A continous occuring in several frames should eventually be recognized.
 
\end_layout

\begin_layout Standard
The second task of my bachelor thesis is thus, to implement a similarity
 meassurement for clusters to merge them over several frames.
 In order to distinguish the clusters which are calculated using the k-means
 algorithm in a single image and the clusters which are generated through
 merging clusters of a video sequence, the latter kind will be refered to
 as 
\begin_inset Quotes eld
\end_inset

super-clusters
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Section
Dynamic clustercount algorithm in video sequences
\end_layout

\begin_layout Standard
Since colorsegmentation in video sequences and images are essentially the
 same problem, the proposed algorithm by Siddheswar Ray and Rose H.
 Turi, would also work in videos.
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

 Due to the assumption that we are only looking at continuous video sequences,
 calculating the optimal clustercount for each frame individually, without
 including any gained knowledge of the previous calculations, would result
 in redundant calculations for most videos.
\end_layout

\begin_layout Standard
Often the optimal clustercount will be unchanged from one frame to the subsequen
t one.
 The resulting cluster will then only vary slightly, either due to an occured
 movement or due to a change of the lightning condition.
 Hence it seems reasonable to look for an effective way to include the gained
 knowledge of the previous frames.
 One option would be to check whether clustercenters of the previous frame
 could be kept as initial center for the k-means algorithm of the current
 frame.
 
\end_layout

\begin_layout Standard
As described in 2.3 the meassure of significance for the number of clusters
 is the validity, it's optimal value always falls on a local minima in compariso
n to a higher/ lower clustercount.
 From this follows that if the clustercenters of the previous frame still
 constitute a local minima in the current frame it is likely that the optimal
 clustercount is unchanged.
 
\end_layout

\begin_layout Standard
Unfortunately there are two major problems with this conclusion.
 Even if the old clustercunters constitute a local minima on the current
 frame it is not guaranteed that it is the optimal solution.
 As described in 2.3 the optimal clustercount for a synthetic image seems
 to be the global minima and in case of a real image it would be the smallest
 validity after the first local maxima.
 Neither for synthetic images, nor for natural images can be checked whether
 the current minima constitutes the optimum without calculating the validity
 for each k.
 
\end_layout

\begin_layout Standard
Even if the optimal number of clusters in a frame would equal the used number
 of clusters in a former one, the old clustercenters might be unfit as initializ
ation points for k-means clustering in the current frame.
 To get a good initialization point, the algorithm of Siddheswar Ray and
 Rose H.
 Turi puts the whole image into a single cluster at first.
 The mean of each pixel builds it's clustercenter.
 Continually the cluster with the highest variance is split into two parts.
 Thus using the old clustercenters as initialization points for k-means
 clustering implies the assumption, that each time a cluster had the highest
 variance in the previous frame, the same cluster would have the highest
 variance in the current frame as well.
 
\end_layout

\begin_layout Standard
Despite the occuring problems, using the local minima assumption seems to
 be a good indicator to either keep the old clustercenters as initialization
 points or start all over.
 Because the stated problems are only expected to occure rarely, due to
 mostly small occuring changes when transitioning from one frame to another.
 The impact of identifying the wrong clustercount in a video sequence will
 be further discussed in the evaluation of this algorithm.
\begin_inset Foot
status open

\begin_layout Plain Layout
see 4.4 implementation in a video sequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
To check whether the old clustercenters still constitutes a local minima
 the clustercenters for k+1 and k-1 have to be determined.
 For k+1 the same process as previously described can be used and the cluster
 with the highest variance will be split.
\begin_inset Foot
status open

\begin_layout Plain Layout
see 2.3 Optimal clustercount
\end_layout

\end_inset

 Unfortunately it is not possible to simply remerge two clusters, because
 there is no indicator as the variance, which defines the clusters who have
 previously belonged together.
 To get the validity for k-1 the corresponding clustercenters of the previous
 cycle from algorithm 2.2 has to be used as initialization point, although
 this clustercenters haven been generated using a previous frame.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {Split the video sequence into frames} 
\end_layout

\begin_layout Plain Layout


\backslash
State {Use algorithm 2.2 to find the optimal k for the first frame and save
 the clustercenters for each iteration of k}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat{ for each frame}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use standard k-means with existing clustercenters and calculate the
 validity}
\end_layout

\begin_layout Plain Layout


\backslash
State {Save the clustercenters for subsequent frames}
\end_layout

\begin_layout Plain Layout


\backslash
State {Split the cluster with the highest variance}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use the k-means algorithm and calculate the validity for k+1}
\end_layout

\begin_layout Plain Layout


\backslash
State {Save the clustercenters for subsequent frames}
\end_layout

\begin_layout Plain Layout


\backslash
State {Get the clustercenters of k-1 of the previously stored iterations}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use the k-means algorithm and calculate validity for k-1}
\end_layout

\begin_layout Plain Layout


\backslash
If {validity of k-1 > validity of k <= validity of k+1}
\end_layout

\begin_layout Plain Layout


\backslash
State { 
\backslash
textbf{continue} }
\end_layout

\begin_layout Plain Layout


\backslash
Else 
\end_layout

\begin_layout Plain Layout


\backslash
State {Use algorithm 2.2 and save the clustercenters for each iteration of
 k}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
Until {all frames are processed}
\end_layout

\begin_layout Plain Layout


\backslash
State {Group the clusters into super-clusters according to a similarity
 meassurement}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The adapted algorithm to find the optimal clustercount in video sequences
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This algorithm will save computational time in cost of accuracy.
 In some special cases it will provide non optimal solutions, this will
 further be outlined in chapter 4.
 
\end_layout

\begin_layout Section
Similarity meassurement of clusters occuring over several frames
\end_layout

\begin_layout Standard
In order to find a suitable similarity meassurement for comparing clusters,
 it is important to keep track of the final goal.
 The fusion of severall similar clusters, into one super-cluster should
 finally provide information of the whole video.
 The basic k-means colorsegmentation algorithm as described in 2.2 and is
 repeatedly used in 2.3, would ultimately only provide minimal information
 via the culstercenters.
 
\end_layout

\begin_layout Standard
For example if only the euclidian distance of each clustercenter would be
 compared and the most similar ones would be merged, the gained information
 could be seen as color histogramm of the whole video sequence.
 One improvement step is to not only include the colorspaces, but also the
 size to compare clusters.
 Clusters which share a color with another clustercenter but are ultimately
 unconnected, might already be separated and not part of the same super-cluster.
 
\end_layout

\begin_layout Standard
But without including the coordinates in any way, clusters cannot include
 any information about shape and may contain disjointed areas.
 For example in Figure 3.1 the optimal clustercount would be determined as
 2.
 One cluster for the background and one for the red rectangels.
 To split clusters not only according to their color, but also according
 to their geometrical distinctness, the coordinates of each pixel need to
 considered when calculating the clusters.
 Only then the optimal clustercount of 3 could be achieved for the image
 in Figure 3.1.
 
\end_layout

\begin_layout Standard
There are several way to include geomatrical features, but it would be optimal
 if reasonable results could be achieved with the k-means clustering algorithm
 itself.
 The basic idea hereby is to extend the feature space from a 3d-vector which
 includes the colorspace, to a 5d-vector which also includes the XY-coordinates.
 The major problem is to find a scale of the geometric features to the color
 features, so that reliable reasonable clusters can be generated independent
 of the particular image.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
An dieser Stelle bereits mehr erzählen, oder erst später?
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/beispiel.png

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Example of wrong clustercount without including pixel coordinates
\end_layout

\end_inset


\end_layout

\end_inset

A different approach to include geomatrical knowledge, is to detect shapes
 in the already separated clusters, created by the kmeans colorsegmentation
 algorithm.
 The OpenCV library already implements the necessary functions for doing
 so.
 The relevant clusters first have to be converted into a blured grayscale
 image and the saturation has to be adjusted.
 This leads to a better thresholding, when converting the grayscale image
 into a pure binary one.
 The binary image will then be used to detect the edges.
 The openCV method 
\begin_inset Quotes eld
\end_inset

findContours(...)
\begin_inset Quotes erd
\end_inset

 will try to calculate the corresponding contours.
 Contours can be seen as boundaries, and in contrast to edges they form
 closed curvatures.
 If there are several contours convoluted in each other as for example seen
 in Fig 3.2, only the most outer one is relevant and will represent a cluster.
 In the case of the image in Fig 3.2 the only relevant contours are labeled
 from 0-2, because the remaining contours are all enclosed in contour 2.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/hierarchy.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example for hierachy in edge detection
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
(Source: http://docs.opencv.org/trunk/d9/d8b/tutorial_py_contours_hierarchy.html)
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Bildquelle richtig angeben
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Results and Evaluation
\end_layout

\begin_layout Section
Evaluation of the optimal clustercount
\end_layout

\begin_layout Subsection
On synthetic images
\end_layout

\begin_layout Standard
The results reported from Siddheswar Ray and Rose H.
 Turi 
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

 on synthetic images described in 2.3, could mostly be verified.
 On very simple images as seen in Fig 4.1 the automatically specified clustercoun
t matches the actual used colors.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/beispiel.png
	scale 75

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/beispiel2.png
	scale 37.5

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/beispiel3.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated images with known used number of colours
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surprisingly the calculated optimal clustercount using the RGB colorspace
 and a maximal clustercount of 25 in Figure 4.2 was determined as 10 instead
 of the expected 5 clusters.
 This error occurs due to the different numbers of colors used in differing
 shapes.
 Each rectangle consists of only of one specific color, whereas the circle
 can be distinguished into several RGB-values.
 The core of the circle and everything in close distance has only one colorvalue
, but the closer the distance to the boundary the pixelcolor changes in
 order to achieve an effect of anti aliasing.
 Anti aliasing makes the rectangle shape of pixels on a computer display
 less visible for the human eye.
 In this specific case the circle consists of 49 different RGB values.
 Due to the relationship of inter cluster distance and intra clusterdistance
 the circle is split into 5 different clusters.
 The conversion into HSV did not result in a calculated clustercount of
 5 either, instead it went up to 13 (keeping the euclidian distance as distance
 meassurement).
 As described in 2.4 the different nature of the RGB colorspace and HSV colorspac
e results in different distances in between colors.
 Many of the 49 RGB colors will probably share the same hue value, but can
 be further clustered according to the saturation and brightness, which
 therefore results in different clusters in comparison to the RGB colorspace
 and with it to a rise of the calculated optimal clustercount.
\end_layout

\begin_layout Standard
Given that the used colors in a natural images is expected to be a lot higher
 than 53, the performed clustering will never be on a comparable fine level.
 The decrease of the intra cluster distance would lead to a lower inter
 cluster distance and supposably the validity would increase.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/circle.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/circle_HSV.png
	scale 50

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated image including a circle converted into HSV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Increasing the number of circles and adding more colors overall to testing
 images as for example seen in Figure 4.3, resulted in a correct computation
 of the clustercount in RGB colorspace.
 The particular image is built of 4564 RGB values and the right clustercount
 of 10 is calculated.
 Transfering this image into the HSV colorspace resulted in the computation
 of 7 as optimal clustercount, when using the normal euclidian distance.
 The conversion into the HSV colorspace is expected to be closer to the
 human expectation in natural images.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Fußnote auf 2.4, oder Liternaturnachweis
\end_layout

\end_inset


\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/4564colors.jpg
	scale 40

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/colors_to_HSV.png
	scale 40

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated image build of 4564 RGB values converted into HSV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
On real images
\end_layout

\begin_layout Standard
Until now the clutercount was only tested on self generated images with
 known optimal clustercount.
 On real images this is usually only vague estimable.
\end_layout

\begin_layout Standard
The algorithm was tested clustering images of the Berkeley Segmentation
 Dataset and provided satisfactory results.
 To evaluate the dynamic cluster count it was compared to the clusters generated
 through incrementing the number of clusters as described in algorithm 2.2.
 The evaluation however is bound to subjective perception.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Zwar kein optimaler Wert bekannt, könnte aber mit kleineren K verglichen
 werden
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_4_optimal.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{optimal k = 4} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_5.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 5} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_10.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 10} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Snow shoes example from the Berkeley Database clustered in RGB-colorspace
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The optimal cluster count of 4 in Fig 4.4 seems to retain most key features
 of the image, the results seen in c) and b) seem to be similarly good and
 the cluster count of 10 might be preferable due to the existance of a cluster
 solely for the snow shoes.
 The latter impression probably arises of our focus on the image center,
 the clustering algorithm values each pixel likewise.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rgb_6_optima
l.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{optimal k = 6} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rg
b_3.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rgb_8.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 8} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Airplane example from the Berkeley Database clustered in RGB-colorspace
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The calculated optimal cluster count of 6 in Fig 4.5 seems to be the most
 adequate cluster number, although k=3 seems to highlight the plane better.
 However k-means clustering is an sunsupervised algorithm without prior
 knowledge, hence the cluster count of 6 retains more information of the
 background as well.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/5096.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/5096_rgb_4_optima
l.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{optimal k = 4} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/5096_rg
b_3.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/5096_rgb_6.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 6} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Stone gate example from the Berkeley Database clustered in RGB-colorspace
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The optimal cluster count of 4 in Figure 4.6 seems to maximise the inter
 cluster distance and retains most visible features.
 Increasing the clustercount mostly sharpens the edges, thus k = 4 seems
 to be the right choice.
 
\end_layout

\begin_layout Standard
Using the HSV-colorspace instead of the RGB-colorspace did not lead to considera
bly better results.
 Strikingly the calculated optimal clustercount was mostly higher in HSV
 as for example seen in Figure 4.7.
 Otherwise the same findings as in the RGB-colorspace could be made.
 Overall the comparison did not favor any colorspace.
 The results were on a subjective focus on the same level.
 To determine which, colorspace should be used should depend on the final
 task of the clustering algorithm.
 Because the following work is rather on an abstract level than on implementing
 the algorithm on a particular task and because the underlying algorithm
 for determining the cluster count was originally propsed for the RGB colorspace
, the latter one will be used on the implementation for video sequences.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_rgb_4.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{optimal k = 4 (RGB)} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_hs
v_6.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{optimal k = 6 (HSV)} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_hsv_6_to_rgb.
png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{c) converted into RGB} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of results in RGB and HSV colorspaces
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation in a video sequence
\end_layout

\begin_layout Subsection
On synthetic video sequences
\end_layout

\begin_layout Standard
Implementing the dynamical clustercount into a simple synthetic video sequence
 as describe in algorithm 3.1, revealed that the clustercount incremented
 correctly when necessary, but failed to detect required reductions of k.
\end_layout

\begin_layout Standard
Figure 4.14 shows an example of a video sequence.
 In cluster 1 to 4 the clustercount stays the same and is recognized correctly.
 The new appearance of a rectangle in cluster 5 leads to a new clustercount
 calculation.
 In cluster 6 the green rectangle is gone and a new clustercount calcuation
 should be the result, but the algorithm fails to identify the change and
 keeps the old clustercount.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/simple_VidExample0.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/simple_VidExample1.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/simple_VidExample2.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/simple_VidExample3.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/simple_VidExample4.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/simple_VidExample5.png
	scale 50

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/simple_VidExample6.png
	scale 50

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout

\lang ngerman
A simple videosequence where areas are moving out of the video
\begin_inset Argument 1
status open

\begin_layout Plain Layout
Example of a simply videosequence
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
As long as something is added to the scene, the variance calculation of
 previous runs for determing the clustercount will still be meaningful for
 the current frame.
 If the clusters are calculated with k-means using the clustercenters of
 the previous frame as initialization points, the generated clusters will
 have a higher variance if a new area is added to the scene.
 Thus the validity meassure will usually decrease if the number of clusters
 is increased, this is the same principle used in algorithm 2.2.
 Even if the algorithm for identifying the optimal clustercount, would have
 split clusters in a different way if run on the current image, the disparity
 can still be regulated.
 For the transformation from k to k+1, the k-means algorithm splits the
 cluster with the highest variance on the current image.
 In contrast the initialization points for k-1 are solely received via the
 calculation on previous frames.
 Therefore the calcuations of the validity for k-1 needs to be improved.
 One possibility for doing so, is to use the same procedure as k+1 received
 already.
 Instead of calculating the validity for k-1 immediately, the clustercenters
 for k-2 (if k>3) will be used as initialization points.
 The new clusters will be split once again as described in 2.3 and the arising
 clustercenters will be used to calculate the the validity for k-1.
 Another improvement can be achieved, when the order of the validity checks
 is changed.
 The validity for k-1 will be checked first, the generated clusters will
 be split twice and used to calculate the validity for k and k+1.
\end_layout

\begin_layout Standard
With this slight modification the algorithm achieved the right cluster count
 results on simple video sequences (as for example seen in Figure 4.14) as
 long as the conditions remained constant.
 The considered cases included appearing and disappearing areas (solely
 and simultaneously).
 Adding bluring, noise or light effects to an image however resulted most
 often in a different clustercount than before, indicating unstableness
 in real images on changing conditions.
 But the impact of these effects on simple images with only few features
 is expected to be stronger and less subtle than real occuring condition
 changes in most video sequences.
\end_layout

\begin_layout Standard
To actually compare the produced clusterscenters over several frames, the
 generated clustercenters of the first frame were used as the first centers
 of 
\begin_inset Quotes eld
\end_inset

super-clusters
\begin_inset Quotes erd
\end_inset

 (merged clusters of frames).
 On each iteration of the algorithm, after the optimal number of clusters
 has been identified, the new clustercenters will be compared to to the
 centers of existing super-clusters.
 For comparison the usual euclidian colorspace distance and the euclidian
 distance of the coordinate centers of the clustercenters and the super-clusters
 were calculated.
 In order to add them, they had to be normalized.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{color}=|v_{color\,1}-v_{color\,2}|
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{coord}=|v_{coord\,1}-v_{coord\,2}|
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{v1\,v2}=d_{color}+d_{coord}
\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $v_{1}$
\end_inset

being the normalized clustercenter and 
\begin_inset Formula $v_{2}$
\end_inset

being the normalized center of the super-cluster.
 
\begin_inset Formula $v_{color}$
\end_inset

only includes the colorinformation and 
\begin_inset Formula $v_{coord}$
\end_inset

only includes the centercoordinates.
\end_layout

\begin_layout Standard
If the sum of both distances of the closest super-cluster was smaller than
 a self-determined 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the clustercenter belonged to the super-center.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{v1\,v2}<d_{max\cdot\delta}=\delta_{dis}
\]

\end_inset

In this case the center of the super-cluster had to be updated.
 Thus the old center of the super-cluster is simply replaced with the newest
 member.
 To get to a good 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the maximal possible distance should be considered and scaled accordingly.
 An alternative approach would be to add the center of the cluster to the
 center of the super-cluster and divide it by 2.
 This would lead to more stable results, as soon as one outlier appears
 and the center is shifted in the wrong direction, it is likely that new
 clusters will not be assigned to the right super-cluster.
 But normally we expact clusters to move continously in the same direction,
 hence the first method should lead to better results.
\end_layout

\begin_layout Standard
Otherwise if the distance to the closest super-cluster was bigger than 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the clustercenter is not part of an existing supercluster and it's values
 will be the initial values of a new super-cluster.
\end_layout

\begin_layout Standard
This method generated the right results for simple synthetic video sequences
 and a reasonable 
\begin_inset Formula $\delta$
\end_inset

.
 For example for the video sequence seen in Fig 4.14 
\begin_inset Formula $\sim0.06<\delta<0.6$
\end_inset

 produced right results.
 Overall we expect 
\begin_inset Formula $\delta=0.15$
\end_inset

 as good threshold.
\end_layout

\begin_layout Subsection
On real video sequences
\end_layout

\begin_layout Standard
The adapted algorithm was tested on real video sequences and the adaptive
 cluster count was compared to the outcome produced by it's predecessor
 algorithm developed by Ray and Rose H.
 Turi
\begin_inset Foot
status open

\begin_layout Plain Layout
algorithm 2.2
\end_layout

\end_inset

, where each frame was processed individually.
 
\end_layout

\begin_layout Standard
The adapted and unapted algorithms produced the same cluster count on most
 frames, however the adapted algorithm tended to switch the cluster count
 less times than the unapted one.
 This outcome had to be expected, as described in 3.1 the adapted algorithm
 will not change the clustercount if the validity currently constitutes
 a local minima, whereas the unadapted algorithm will always go with the
 global minima.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Wenn Zeit Tabelle und Abb auf eine Seite
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/cars1_01.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_02.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_03.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_04.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_05.jpg
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/cars1_06.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_07.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_08.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_09.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_10.jpg
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/cars1_11.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_12.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_13.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_14.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_15.jpg
	scale 15

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/cars1_16.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_17.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_18.jpg
	scale 15

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/cars1_19.jpg
	scale 15

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of a video sequence used for evaluation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout

	
\backslash
centering 
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{subtable}{.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout

		
\backslash
centering
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{tabular}{ccl}
\end_layout

\begin_layout Plain Layout

		
\backslash
toprule
\end_layout

\begin_layout Plain Layout

		Frame & k & super-clusters 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
midrule
\end_layout

\begin_layout Plain Layout

		1 & 6 &  0 1 2 3 4 5 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		2 & 6 &  0 1 2 3 4 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		3 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		4 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		5 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		6 & 5 & 0 1 2 3 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		7 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		8 & 6 & 0 3 2 4 1 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		9 & 8 & 0 5 2 4 1 6 3 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		10 & 8 & 0 5 2 4 1 6 3 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		11 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		12 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		13 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		14 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		15 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		16 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		17 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		18 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		19 & 5 & 0 2 1 7 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout

		& & 8 super-clusters
\end_layout

\begin_layout Plain Layout

		
\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

		
\backslash
caption{results for Fig 4.14 using the unadapted algorithm}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{subtable}%
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{subtable}{.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout

		
\backslash
centering
\end_layout

\begin_layout Plain Layout

		
\backslash
begin{tabular}{ccl}
\end_layout

\begin_layout Plain Layout

		
\backslash
toprule
\end_layout

\begin_layout Plain Layout

		Frame & k & super-clusters 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
midrule
\end_layout

\begin_layout Plain Layout

		1 & 6 &  0 1 2 3 4 5 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		2 & 6 &  0 1 2 3 4 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		3 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		4 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		5 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		6 & 5 & 0 1 2 3 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		7 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		8 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		9 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		10 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		11 & 5 & 0 1 2 3 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		12 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		13 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		14 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		15 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		16 & 5 & 0 1 2 3 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		17 & 5 & 0 1 2 3 6 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

		18 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		19 & 5 & 0 1 2 3 6 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

		
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout

		& & 7 super-clusters
\end_layout

\begin_layout Plain Layout

		
\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

		
\backslash
caption{results for Fig 4.14 using the adapted algorithm}
\end_layout

\begin_layout Plain Layout

	
\backslash
end{subtable} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout
The results produced on the video sequence of Figure 4.10 in RGB
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The results presented in Table 4.1 don't necessarily have to compromise the
 results, it would highly depend on the further use.
 Due to the mostly unchanging cluster count, the generated clusters are
 more similar and thus merged into less super-clusters.
 This might be useful for tracking the movement of an object.
 If the object is recognized in one of the clusters of the first frame,
 the corresponding super-cluster might ease the recognition in the following
 clusters.
 However it is unlikely that the features of an object is completely put
 into one cluster.
\end_layout

\begin_layout Standard
The super-clusters could also be used to compress the data size of the video
 sequence.
 The whole video can be encoded to only 7 colors when using the adapted
 algorithm.
 For other purposes it is hardly possible to rate the performance of this
 algorithm in reference to the super-clusters, due to the lack of similar
 scientific work.
 If the clusters would actually possess striking visual features the super-clust
ers could be evaluated furhter.
 Therefore it makes sense to try to include geomatrical features as well.
\end_layout

\begin_layout Section
Evaluation of k-means clustering with a 5d-feature vector
\end_layout

\begin_layout Standard
Using a 5D-feature vector, consisting of the colorspace and the geomatric
 features promises two main advantages.
 Clustered regions would be closer to semantic knowledge, since regions
 with similar colors are already split and thus the results are more useful
 for comparing clusters over the cause of a video sequence.
 Overall the expectation is, that the resulting outcome is closer to semantical
 knowledge.
 Furthermore after the k-means algorithm has clustered each frame separately,
 the whole outcome can build a new dataset, which then again can be clustered
 via k-means to fuse the clusters of each frame into super-clusters holding
 information of the whole video sequence.
 The requirement to do so are reliable generated reasonable results when
 clustering single images.
 
\end_layout

\begin_layout Standard
To get reasonable images the 5d-feature vector has to be normalized first.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{5d-feature Vector: }\overrightarrow{v}=\begin{array}{c}
r\\
g\\
b\\
x\\
y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overrightarrow{v}_{normalized}=\begin{array}{c}
\frac{r}{255}\frac{1}{3}\\
\frac{g}{255}\frac{1}{3}\\
\frac{b}{255}\frac{1}{3}\\
\frac{x}{\max X}\frac{1}{2}\alpha\\
\frac{y}{\max Y}\frac{1}{2}\alpha
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\alpha$
\end_inset

 is the scaling factor.
 Usually the colorspace will be seen as more important than the geometric
 features, so 
\begin_inset Formula $\alpha$
\end_inset

 will be close to zero.
 
\end_layout

\begin_layout Standard
The same normalization procedure should theoratically be applied on the
 variance calculation as well.
 Unfortunately due to the incoherent shape of the background, the cluster
 containing the backgroundarea often had the highest variance out of the
 calculated clusters.
 Figure 4.9 shows an example of this occurance, the white area represents
 the not contained area of the specific cluster.
 The algorithm gets the right result for 
\begin_inset Formula $k=2$
\end_inset

 and 
\begin_inset Formula $\alpha=0.004$
\end_inset

 (a ratio of 250:1), but it splits the background further for 
\begin_inset Formula $k=3-5.$
\end_inset


\begin_inset Foot
status open

\begin_layout Plain Layout
Using the algorithm 2.2 to determine the optimal clustercount
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/beispiel.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{source image} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.25
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 1} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters2.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 2} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters3.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of single clusters when splitting the wrong cluster using a 5d-feature
 vector
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ignoring the geometrical features while calculating the variance lead to
 better results in the case of Figure 4.9, but only by chance since the rectangle
s were the first cluster in 
\begin_inset Formula $k=2$
\end_inset

.
 In order to split the right cluster a different meassurement than the variance
 would be needed.
 Even without considering the variance as meassurement to find the right
 cluster to split, the underlying porblem of finding the right ratio of
 the geometrical features to the colorspace can not be ignored.
 For many images it might even be the case, that there exists no appropriate
 ratio of color features and geomatrical features, which will lead to meaningful
 clusters.
 A potential instance of this will be further discussed later in 4.4.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Besssere? Verknüpfung zu Ergebnissen aus 4.4
\end_layout

\end_inset


\end_layout

\begin_layout Section
Evaluation of the alternative approach
\end_layout

\begin_layout Standard
Due to the inefficiency using a 5d-feature vector, especially with the problem
 of getting a right meassure for the optimal clustercount, it seems easier
 to separate the splitting according to color features and the splitting
 according to geometrical features into two processes.
 Instead of clustering with a 5d-feature vector, the well performing 3d-vector
 including only the colorspace can be retained and each cluster might be
 further divided.
 
\end_layout

\begin_layout Standard
We only want to divide clusters with clear geomatrical boundaries further.
 Hence if it is possible to draw several polygons without overlapping, where
 the area of the polygons are made up by the pixels of the clusters, the
 polygons will built new clusters.
\end_layout

\begin_layout Standard
This can be achieved using the openCV library.
\begin_inset Foot
status open

\begin_layout Plain Layout
specific process explained in 3.4
\end_layout

\end_inset

 Hereby one major problem needs to be considered.
 The cluster(s) which hold the colorinformation of the background might
 lead to the same detected boundaries as the clusters which are actually
 surrounded by the background.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters_background.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{images/contours0.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/contours1.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example images for the occuring background problem when calculating boundaries
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first image of 4.10 shows the image which will be clustered.
 Obviously it will result in two clusters, when determining the optimal
 clustercount.
 The first one will only hold the two red rectangles, while the second one
 will hold the background.
 The cluster containing the background can be seen in b).
 The last two images c) and d) show the calculated boundaries.
 Unfortunately this boundaries can be calculated using any of the two clusters.
 Hence if adding the calculated polygons of each cluster to the number of
 clustercenters, the optimal clustercount would be determined as 4 instead
 of 3.
 Thus the calculated polygons should only increase the clustercount if the
 comprised area is filled of the pixels which are part of the cluster, which
 was used for calculating it.
 Thus this needs to be checked.
 
\end_layout

\begin_layout Standard
Furthermore clustercenters should also include coordinates in order to get
 coherent clusters.
 In each iteration of the basic k-means algorithm, the mean of the coordinates
 of each updated cluster will form the clustercenter together with the correspon
ding colorfeatures.
 
\end_layout

\begin_layout Standard
When splitting the cluster further using the described method, the new clusterce
nters will be built up of the same colorfeature but will be separated according
 to the new mean of the coordinates of each polygon.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {calculate the mean of the coordinates of each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
State {update the clustercenter including the coordinate information}
\end_layout

\begin_layout Plain Layout


\backslash
State {convert each cluster into a grayscale image and adjust the saturation}
\end_layout

\begin_layout Plain Layout


\backslash
State {convert each cluster into a binary image}
\end_layout

\begin_layout Plain Layout


\backslash
State {detect the (outer) boundaries of each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
For {each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
If {Several polygons are detected and the pixels inside of the polygons
 are part of the current cluster }
\end_layout

\begin_layout Plain Layout


\backslash
State {Delete the old clustercenter of this clustercenter}
\end_layout

\begin_layout Plain Layout


\backslash
State {Calculate the mean of the coordinates inside of the boundary}
\end_layout

\begin_layout Plain Layout


\backslash
State {Built new clustercenters according to the calculated coordinates
 and the old colorfeature}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Find geomatrical features of clusters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of the advantages of the k-means algorithm is, that each pixel is assigned
 to the corresponding clustercenter.
 The assignment could be done in different ways.
 Because the splitting of the clusters happens according to the calculated
 boundaries, it seems logical to check whether the pixels of the original
 cluster lie inside of the the calculated polygon and assign them accordingly.
 Alternatively the calculated clustercenters could be used as starting points
 for k-means clustering with either the 5d-vector of 4.2 or using a 2d-vector
 consisting of the coordinates on the particular cluster.
\end_layout

\begin_layout Standard
Both assignment methods have some flaws.
 The created boundaries are not completely accurate and hence some pixel
 are not inside of the polygon and will fall through the first method.
 The second method doesn't consider boundaries at all, the k-means algorithm
 will simply check which pixel is on the shortest distance to the specific
 cluster.
 The last image of Figure 4.11 shows this quite good.
 Adjusting the scale value 
\begin_inset Formula $\alpha$
\end_inset

 did not lead to the desired result and only adjusted distribution of the
 clusters slightly.
 The areas are too close together.
 Either the pixel distance, or the colors are required too be further divided
 in order to get correct results.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/example_alt.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/example_altCluster.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{flaws via polygon check}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/finalK_12cluster_9.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{flaws via k-means}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of boundary cluter assignment and k-means
\end_layout

\end_inset


\end_layout

\end_inset

On simpler images (as for example the ones seen in Figure 4.2) both methods
 work fine and lead to the expected results.
 Overall the method of checking whether a pixel lies inside of the calculated
 polygon seems to get the closer to the expected results.
 The problem of assigning only few pixels to the wrong cluster, could easily
 be solved.
 For example implementing a noise filter.
 
\end_layout

\begin_layout Standard
On natural images however the described method didn't lead to an increased
 clustercount.
 In all tested cases the contour detection failed to find useful polygons.
 As seen in Figure 4.12 despite using a nearly optimal binary image, the
 resulting contours are not completely aligned.
 Printing all contours in one image shows the potential and might indicate
 how an improved detecting algorithm will improve the results.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_binary.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Binary image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_single_contour.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Best calculated contour}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_all_contours.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{All contours in one image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of a flawed boundary detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The original image of 4.13 presents two snowshoes, the goal would be to split
 the particular cluster so that one features the left snowshoe and one features
 the right one.
 Unfortunately no fitting polygon could be calculated and the clusters remained
 the same.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/2018_binary.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Binary image of interesting cluster}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/2018_contours.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{All resulting contours in one image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Second example of a flawed boundary detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Discussion and conclusion
\end_layout

\begin_layout Standard
Testing the described algorithm by Ray and Rose H.
 Turi lead to mostly similar results as formerly reported.
 Although some flaws need to be considered before using it.
 On very simplistic images the calculated cluster count will separate the
 image into too many clusters due to the possible reduction of the intra
 cluster distance.
 Besides it should be known beforehand whether the investigated image will
 be a synthetic or a real one, but usually this should be no problem and
 is already stated in the original article.
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset


\end_layout

\begin_layout Standard
Adapting the algorithm to generate an adaptive cluster count on video sequences
 proved to work well on synthetic video sequences.
 On natural video sequences the results were satisfactory but did not always
 produce identical results in comparison to the independant calculated ones.
 The effective use of this algorithm would require some further improvements
 for most possible tasks, the computation time is impractical.
 Even if the current cluster count constitutes a local minima the basic
 k-mean algorithm has to be repeated 4 times, otherwise it will aditionally
 be repeated up to the given maximal k.
 
\end_layout

\begin_layout Standard
Creating super-clusters through comparison of clustercenter, which includes
 color- and coordinate information provides knowledge of the movement and
 continuity of existing clusters.
 The information yield and specification of a good threshold 
\begin_inset Formula $\delta_{dis}$
\end_inset

 or even the suggested procedure for creating super-clusters in general
 can only be properly evaluated if the created clusters are closer to semantic
 knowledge.
 This could be achieved through including more features in clustering that
 just the color information.
 The attempt of including geometric features via a 5d-feature vector while
 retaining the basic k-means algorithm did not lead to improved results.
 The main problem was to find a working ratio of the colors and coordinates,
 this ratio should furthermore be dynamic to be universal applicable.
 On some images the 5d-feature vectores could be tested with an approximate
 fitting ratio but could not produce the desired outcome.
 This might be due to one of the big flaws of k-means clustering, it can
 only produce spherically formed clusters, which is especially problematic
 when the coordinates are included in the clustering process.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../bibtex-daten/bachelorarbeit-info"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
