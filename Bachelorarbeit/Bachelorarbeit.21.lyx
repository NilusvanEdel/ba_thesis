#LyX 2.2 created this file. For more info see http://www.lyx.org/
\lyxformat 508
\begin_document
\begin_header
\save_transient_properties true
\origin unavailable
\textclass scrreprt
\begin_preamble
% verschieden Symbole, Zeichen wie (c), €
\usepackage{textcomp,units}

% Mehr Platz zwischen Tabelle und Untertitel
\usepackage{caption}
\usepackage{subcaption}
\captionsetup[table]{skip=10pt}

%Kapitelzahl sehr groß
\makeatletter% siehe De-TeX-FAQ 
 \renewcommand*{\chapterformat}{% 
   \begingroup% damit \unitlength-Änderung lokal bleibt 
     \setlength{\unitlength}{1mm}% 
     \begin{picture}(10,10)(0,5) 
       \setlength{\fboxsep}{0pt} 
       %\put(0,0){\framebox(20,40){}}% 
       %\put(0,20){\makebox(20,20){\rule{20\unitlength}{20\unitlength}}}% 
       \put(10,15){\line(1,0){\dimexpr 
           \textwidth-20\unitlength\relax\@gobble}}% 
       \put(0,0){\makebox(10,20)[r]{% 
           \fontsize{28\unitlength}{28\unitlength}\selectfont\thechapter 
           \kern-.05em% Ziffer in der Zeichenzelle nach rechts schieben 
         }}% 
       \put(10,15){\makebox(\dimexpr 
           \textwidth-20\unitlength\relax\@gobble,\ht\strutbox\@gobble)[l]{% 
             \ \normalsize\color{black}\chapapp~\thechapter\autodot 
           }}% 
     \end{picture} % <-- Leerzeichen ist hier beabsichtigt! 
   \endgroup 
}

\usepackage{ %a4wide,
            ellipsis, fixltx2e, mparhack,   %Fehlerkorrektur für Marginalien
            booktabs, longtable             %schönere Tabellen
}  

\usepackage[automark]{scrpage2}
%\automark[chapter]{chapter}
\clearscrheadfoot
\ohead{\\\headmark}
\ihead{\includegraphics[scale=0.15]{logo.jpg}}%\pagemark}
\ofoot[\pagemark]{\pagemark}


%Kurzfassung und Abstract (englisch) auf eine Seite
\renewenvironment{abstract}{
    \@beginparpenalty\@lowpenalty
      \begin{center}
        \normalfont\sectfont\nobreak\abstractname
        \@endparpenalty\@M
      \end{center}
}{
    \par
}



% schönerer Blocksatz!!
\usepackage{microtype}

\usepackage{ifpdf} % part of the hyperref bundle
\ifpdf % if pdflatex is used

%set fonts for nicer pdf view
 \IfFileExists{lmodern.sty}{\usepackage{lmodern}}
  {\usepackage[scaled=0.92]{helvet}
    \usepackage{mathptmx}
    \usepackage{courier} }
\fi

 % the pages of the TOC are numbered roman
 % and a pdf-bookmark for the TOC is added
 \pagenumbering{arabic}
 \let\myTOC\tableofcontents
 \renewcommand\tableofcontents{
   %\pdfbookmark[1]{Contents}{}
   \myTOC
   \clearpage
   \pagenumbering{arabic}}

%Bezeichungen anpassen
%Babelpaket muß zuvor geladen werden
%\usepackage[ngerman]{babel}
%\addto\captionsngerman{ 
%\renewcommand{\figurename}{Abb.}% 
%\renewcommand{\tablename}{Tab.}% 
%\renewcommand{\abstractname}{Kurzfassung}
%\renewcommand{\nomname}{Abkürzungen}
%}

% Alle Querverweise und URLs als Link darstellen
% In der PDF-Ausgabe
 \usepackage[colorlinks=true, bookmarks, bookmarksnumbered, bookmarksopen, bookmarksopenlevel=1,
  linkcolor=black, citecolor=black, urlcolor=blue, filecolor=blue,
  pdfpagelayout=OneColumn, pdfnewwindow=true,
  pdfstartview=XYZ, plainpages=false, pdfpagelabels,
  pdfauthor={LyX Team}, pdftex,
  pdftitle={LyX's Figure, Table, Floats, Notes, and Boxes manual},
  pdfsubject={LyX-documentation about figures, tables, floats, notes, and boxes},
  pdfkeywords={LyX, Tables, Figures, Floats, Boxes, Notes}]{hyperref}
% algorithm package
\usepackage{algorithm,algpseudocode}

%mehr Platz zwischen Überschrift und Tabelle
\newcommand{\@ldtable}{}
\let\@ldtable\table
\renewcommand{\table}{ %
                 \setlength{\@tempdima}{\abovecaptionskip} %
                 \setlength{\abovecaptionskip}{\belowcaptionskip} %
                 \setlength{\belowcaptionskip}{\@tempdima} %
                 \@ldtable}
% for better tables
\usepackage{caption, booktabs}

\renewcommand\[{\begin{equation}}
\renewcommand\]{\end{equation}}

\usepackage{color, colortbl}
\definecolor{LightCyan}{rgb}{0.88,1,1}

\usepackage{url}
%In dieser Arbeit wird auf die Nomenklatur als Abkürzungsverzeichnis verzichtet. Bei Wunsch wieder aktivieren.
%Nomenklatur als Abkürzungsverzeichnis verwenden
%\renewcommand{\nomname}{Abkürzungsverzeichnis}
%\renewcommand{\nomlabelwidth}{20mm}

%Nomenklatur als Glossar verwenden
%Nur Noetig wenn auch Glossar verwendet wird.
%\renewcommand{\nomname}{Glossar}

%Farbe für Programmcode festlegen
 
\end_preamble
\options pointlessnumbers, abstracton, headsepline,
\use_default_options true
\begin_modules
theorems-ams
\end_modules
\maintain_unincluded_children false
\language british
\language_package default
\inputencoding auto
\fontencoding global
\font_roman "default" "default"
\font_sans "default" "default"
\font_typewriter "default" "default"
\font_math "auto" "auto"
\font_default_family sfdefault
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 120 100
\font_tt_scale 100 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement H
\paperfontsize 12
\spacing other 1.2
\use_hyperref false
\pdf_title "Analyse und Interpretation des Risswachstums an thermisch hochbelasteten Bauteilen für die Fusionsforschung mittels IR Diagnostik und FE Modellierung"
\pdf_author "Timo Schindler"
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref false
\pdf_pdfusetitle true
\papersize default
\use_geometry true
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 0
\index Stichwortverzeichnis
\shortcut idx
\color #008000
\end_index
\topmargin 2.5cm
\bottommargin 2.5cm
\secnumdepth 2
\tocdepth 2
\paragraph_separation skip
\defskip medskip
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle plain
\bullet 2 0 9 -1
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\noindent
\begin_inset ERT
status collapsed

\begin_layout Plain Layout


\backslash
titlepage
\end_layout

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="5" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="center" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="3" alignment="left" valignment="middle" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/UniOsnabrück.GIF
	lyxscale 25
	width 7.5cm

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Institute of Cognitive Science
\begin_inset space \hspace{}
\length 2.5cm
\end_inset


\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell multirow="4" alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
\noindent
\begin_inset VSpace 7cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size larger
Bachelor thesis
\end_layout

\begin_layout Standard
\noindent
\align left

\size large
Adaptive K-Means Clustering of Data Sequences
\end_layout

\begin_layout Standard
Clustering of video sequences with dynamic cluster count and recognition
 of their serial identity
\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\size larger
\begin_inset VSpace 1.5cm
\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="11" columns="2">
<features tabularvalignment="middle">
<column alignment="left" valignment="top">
<column alignment="left" valignment="top">
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
submitted by:
\begin_inset space \hspace{}
\length 1cm
\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linus Edelkott 
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
matriculation number: 950499
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
course of studies: Cognitive Science
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
sentor:
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
MS Julius Schöning
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Prof.
 Dr.
 Gunther Heidemann
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Universität Osnabrück
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
<row>
<cell multicolumn="1" alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Osnabrück, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell multicolumn="2" alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\begin_inset Separator latexpar
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset space ~
\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset VSpace 17.1mm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align left

\series bold
\size huge
\lang ngerman
Declaration of authorship
\end_layout

\begin_layout Standard

\lang ngerman
I hereby certify that the work presented here is, to the best of my knowledge
 and belief, original and the result of my own investigations, except as
 acknowledged, and has not been submitted, either in part or whole, for
 a degree at this or any other university.
\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset VSpace 2cm
\end_inset


\end_layout

\begin_layout Standard
\noindent
\align center

\lang ngerman
\begin_inset Tabular
<lyxtabular version="3" rows="2" columns="2">
<features tabularvalignment="middle" tabularwidth="15cm">
<column alignment="center" valignment="top" width="0pt">
<column alignment="left" valignment="top" width="0pt">
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\lang ngerman
Osnabrück, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
today
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
\begin_inset Note Comment
status open

\begin_layout Plain Layout
Unterschrift
\end_layout

\end_inset


\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Linus Edelkott
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard

\lang ngerman
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList algorithm

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\begin_layout Plain Layout


\backslash
setcounter{page}{3}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
renewcommand{
\backslash
chaptername}{}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
K-means clustering is one of the most often used clustering algorithms for
 image segmentation.
 Image segmentation is the basis for many image analysis techniques and
 thus highly values reliable results and computing time.
 While k-means clustering offers a great deal for the latter part, reliable
 results are sensitive towards the starting positions.
 The starting position is defined as the chosen initial cluster number and
 their respective position.
 
\end_layout

\begin_layout Standard
So far there exists no generally acknowledged optimal solution to compute
 the optimal number of clusters for any given data set a priori.
 One common bypass is to run the algorithm several times with different
 starting points.
 Especially for image segmentation however, many proposals have been made
 to create good starting points for clustering images
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011_km"

\end_inset

.
\end_layout

\begin_layout Standard
The goal of this thesis is to adapt one of these algorithms to video sequences
 and improve it through the gained knowledge from continuous frames.
 The created clusters for each frame should then be compared to its predecessor,
 to determine whether clusters of previous frames persisted.
 Creating an algorithm to identify good starting positions for k-means clusterin
g in video sequences can already be used for video compression on its own,
 but it could also be useful for many fields of video analysis as for example
 feature extraction and object recognition.
 If a cluster contains most visible features of an object, the identification
 of the serial identity of this particular clusters can especially be applicable
 in fields as object tracking.
\end_layout

\begin_layout Standard
The organization of this thesis is as follows.
 Chapter 2 provides some information on clustering and image segmentation
 fundamentals.
 It introduces k-means clustering and an algorithm to find good starting
 positions for k-means clustering in image segmentation.
\end_layout

\begin_layout Standard
Chapter 3 specifies the underlying task of this bachelor thesis and presents
 the developed procedures and algorithms.
\end_layout

\begin_layout Standard
In chapter 4 the results of the performance evaluation are presented successivel
y on synthetic and real data.
 Thereby some necessary tweaks of the proposed algorithm are introduced
 and implemented.
\end_layout

\begin_layout Standard
Chapter 5 reviews the evaluation and concludes the thesis.
\end_layout

\begin_layout Chapter
Theoretical basis
\end_layout

\begin_layout Section
Clustering
\end_layout

\begin_layout Standard
Clustering can broadly be described as classification of data into several
 groups.
 Clustering algorithms are unsupervised learning algorithms, which means
 they make no prior assumptions about the ouput components
\begin_inset CommandInset citation
LatexCommand cite
key "Lucchese_colorimage"

\end_inset

.
\end_layout

\begin_layout Standard
The vague objective is to find 
\begin_inset Quotes eld
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
textit{interesting}
\end_layout

\end_inset

 groupings of training samples
\begin_inset Quotes grd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "VladimirCherkassky2007"

\end_inset

.
 This separation into a number of groups, called clusters, happens according
 to a measure of similarity.
 The goal of the algorithm is to find clusters in a way, that samples within
 are more similar to each other than samples from different clusters and
 thus minimizing the prediction error.
 This is often summarized as the weighting of 
\begin_inset Quotes eld
\end_inset

intra-cluster
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

inter-cluster
\begin_inset Quotes erd
\end_inset

 distance.
 The first one describes the distinction from samples within a cluster,
 whereas the latter is the distance of one cluster to another one
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

.
\end_layout

\begin_layout Standard
Hereby the similarity measurement reflects a priori knowledge, for example
 using standard Euclidean distance on a RGB color space equals the assumption
 that all values have equal importance.
 Nevertheless is the clustering process usually 
\begin_inset Quotes gld
\end_inset

ad hoc
\begin_inset Quotes grd
\end_inset

; the underlying clustering process defines the relevant information itself.
 This makes clustering very generalizable
\begin_inset CommandInset citation
LatexCommand cite
key "VladimirCherkassky2007"

\end_inset

.
\end_layout

\begin_layout Standard
Often clustering algorithms create prototypes.
 A prototype is a data object that is representative of all other objects
 in the cluster.
 In most cases this is simply the average of each data point within the
 cluster.
 Protoypes can be used in many ways, they ease the comparison of clusters
 among each other and can be used for data compression.
 Therefore they are often used as input for further data processing or data
 analysis techniques
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset

.
\end_layout

\begin_layout Standard
One of the most common usage of clustering algorithms is dimensionality
 reduction.
 The goal is to find a mapping from a 
\begin_inset Formula $d-$
\end_inset

dimensional input space 
\begin_inset Formula $R^{d}$
\end_inset

to some 
\begin_inset Formula $m$
\end_inset

 dimensional output space 
\begin_inset Formula $R^{m}$
\end_inset

, where 
\begin_inset Formula $m<d$
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "VladimirCherkassky2007"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
G(x):R^{d}\rightarrow R^{m}
\]

\end_inset


\end_layout

\begin_layout Standard
A good mapping should also possess the inverse function.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
F(z)=R^{m}\rightarrow R^{d}
\]

\end_inset


\end_layout

\begin_layout Standard
Hence the reduced output can be decoded to the original input without losing
 to much information.
 Thus the main features can be kept, while the amount of data is reduced.
\end_layout

\begin_layout Standard
Clusters can either be described hierarchically (i.e.
 described in tree structures) or they can be purely partitional.
 The latter sort can be further divided into 2 groups.
 The first one is called 
\begin_inset Quotes gld
\end_inset

hard clustering
\begin_inset Quotes grd
\end_inset

, each sample is definitely placed in only one cluster.
 The second one is called 
\begin_inset Quotes gld
\end_inset

soft clustering
\begin_inset Quotes grd
\end_inset

 and in alternative each sample can belong to serveral clusters according
 to a related probability distribution.
\begin_inset CommandInset citation
LatexCommand cite
key "Poole2010"

\end_inset


\end_layout

\begin_layout Section
K-means clustering
\end_layout

\begin_layout Standard
K-means clustering is one of the oldest and most widely used clustering
 algorithms.
 It requires an explicit distance measure, an input of training samples
 and the number of classes k.
 It belongs to the class of hard clustering algorithms.
\begin_inset CommandInset citation
LatexCommand cite
key "Poole2010"

\end_inset

 
\end_layout

\begin_layout Standard
The main concept is to represent each cluster by the vector of mean attribute
 values for numeric attributes or by a vector of the most frequent values
 for nominal attributes that are assigned to that cluster
\begin_inset CommandInset citation
LatexCommand cite
key "IBM_BigInsights"

\end_inset

.
 In contrast to numeric values, nominal attributes can not simply be ordered
 and have only a limited set of values.
 This kind of representation is also called cluster center and acts as a
 prototype.
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset


\end_layout

\begin_layout Standard
The operation of k-means clustering can be seen in algorithm 2.1.
 It starts with initializing random points as centroid of a cluster.
 This initialization process will be repeated until the desired number K
 of clusters is generated.
 The next step is to assign every training sample to the closest cluster
 center and update it by shifting it to the mean of all cluster members
 for each attribute.
 This step has to be repeated until it converges, due to bad initialization
 points this might take many iterations.
 Hence the usual implementation either uses a limit for the number of iterations
 or stops if the number of changes fall below a certain 
\begin_inset Formula $\epsilon$
\end_inset

.
 
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Basic K-means algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {select K points as initial centroids}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat {}
\end_layout

\begin_layout Plain Layout


\backslash
State {assign each data sample to the closest center}
\end_layout

\begin_layout Plain Layout


\backslash
State {update the cluster centers by shifting them to the mean of each attribute
}
\end_layout

\begin_layout Plain Layout


\backslash
Until {centroids moved no more than $
\backslash
epsilon$}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/example_kmeans.png
}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Original points} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/example_kmeans_or
iginal.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Cluster centers with k = 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of k-means clustering on data with distinct groups
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The k-means algorithm aims to minimize an objective squared error function:
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
J=\sum_{j=1}^{k}\sum_{\forall i}|x_{i}^{j}-c_{j}|^{2}
\]

\end_inset

hereby 
\begin_inset Formula $c_{j}$
\end_inset

 is the coordinate vector of the 
\begin_inset Formula $j$
\end_inset

th cluster, 
\begin_inset Formula $\{x_{i}^{j}\}$
\end_inset

 are the points assigned to the 
\begin_inset Formula $j$
\end_inset

th cluster and 
\begin_inset Formula $|x_{i}^{j}-c_{j}|$
\end_inset

 describes the distance
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011_km"

\end_inset

.
 It can be shown that the k-means algorithm converges to a local minimum
\begin_inset CommandInset citation
LatexCommand cite
key "Fu1981"

\end_inset

.
\end_layout

\begin_layout Standard
The relevant distance measure can be chosen dependent on the task, but most
 of the times the normal Euclidean distance is used.
 
\begin_inset Newline newline
\end_inset


\begin_inset Formula 
\[
\text{Euclidean distance: }\frac{1}{I}\cdot\forall i\left(\sqrt{x_{i}-c_{i}}\right)^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
An advange of k-means clustering is its low complexity but it has some weaknesse
s.
 K-means struggle with outliers, which highly influence the results.
 It can also only be used on data for which there is a centroid and it cannot
 handle non-globular clusters as seen in Figure 2.2.
 Finally it has the requirement of getting an accurate number of clusters
 as input a priori
\begin_inset CommandInset citation
LatexCommand cite
key "Bora2015,Pang-NingTan2005"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/example_kmeans_no
global_source.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Original points} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/example_kmeans_no
global.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Cluster centers with k = 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Example of k-means clustering on data with non-globular clusters
\begin_inset CommandInset citation
LatexCommand cite
key "Pang-NingTan2005"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Image color segmentation
\end_layout

\begin_layout Standard
One of the many applications for the k-means clustering algorithm is color
 segmentation.
 Image segmentation in general is the process of splitting/classifying an
 image into several parts, so that each region builds a homogenous segment.
 Combining any of the homogenous segments would result in a heterogenous
 segment
\begin_inset CommandInset citation
LatexCommand cite
key "Bora2015"

\end_inset

 .
\end_layout

\begin_layout Standard
Segmentation algorithms are often the very first step in image processing.
 Subsequent steps as for example feature extraction and classification are
 highly reliant on the successful generation of homogenous parts.
 If the respective object can not be identified, it can certainly not be
 classified.
 The segmentation outcome will always be dependent on the underlying image
 and the object, or feature which should be identified.
 Therefore there is no single perfect clustering for an image, this complicates
 the evaluation process
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset

.
\end_layout

\begin_layout Standard
Segmentation algorithm can be divided into two main groups.
 The first one is the edge/boundary group; the associated algorithms aim
 to detect edges to find boundaries in between groups of pixels.
 The second group is region based and tries to order pixels according to
 their mutual similarity
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset

 .
\end_layout

\begin_layout Standard
Color image segmentation is usually residing in the second group.
 Combined with texture segmentation, it is mostly used in tasks concerned
 about content based retrieval
\begin_inset CommandInset citation
LatexCommand cite
key "Lucchese_colorimage"

\end_inset

.
 Hereby images are organised/searched according to their pictured content.
 
\end_layout

\begin_layout Standard
Clustering algorithms share the same problem as region based segmentation
 and can thus be used for color segmentation.
 The problem of using k-means clustering for image segmentation is once
 again the requirement to assing the number of clusters beforehand.
 If a good number of clusters is known however it is optimal in minimizing
 the average distortion
\begin_inset CommandInset citation
LatexCommand cite
key "Park1998"

\end_inset

.
\end_layout

\begin_layout Section
Finding the optimal numbers of clusters for k-means clustering
\end_layout

\begin_layout Standard
Although the k-means clustering is relatively easy to implement on a relative
 wide field, it has some drawbacks.
 The final results of the clustering algorithm vary depending on the number
 of clusters and especially on their initialization.
 So if the initial clusters are chosen randomly, it will lead to different
 results
\begin_inset CommandInset citation
LatexCommand cite
key "IMCIP-2015"

\end_inset

.
\end_layout

\begin_layout Standard
In order to find the optimal number of clusters and initialize them automaticall
y Siddheswar Ray and Rose H.
 Turi
\begin_inset Note Note
status open

\begin_layout Plain Layout
namen richtig?
\end_layout

\end_inset

 proposed an algorithm which uses 
\begin_inset Quotes eld
\end_inset

a simple validity measure based on the intra-cluster and inter-cluster distance
 measure
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

.
 
\end_layout

\begin_layout Standard
The basic k-means algorithm minimizes the sum of squared distanced from
 all points to their cluster centers, hence the distances from each point
 to their cluster centers provides the information whether the clusters
 are compact.
 The averages of all these distances constitute the intra-cluster measurement.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{intra}=\frac{1}{N}\sum_{i=1}^{K}\|x-z_{i}\|^{2}
\]

\end_inset


\end_layout

\begin_layout Standard
where 
\begin_inset Formula $N$
\end_inset

 is the number of all pixels, 
\begin_inset Formula $K$
\end_inset

 is the cluster count and 
\begin_inset Formula $z_{i}$
\end_inset

 is the actual cluster center.
 To be as compact as possible, we obviously want to minimize this measurement.
 The inter-cluster measurement in contrast describes the distances between
 the cluster centers and should be maximized.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{inter}=\min\left(\|z_{i}-z_{j}\|^{2}\right),i=1,2,...,K-1,j=i+1,...,K
\]

\end_inset


\end_layout

\begin_layout Standard
Only the minimum of each distance is considered, because we always want
 to maximize the smallest distances.
 The maximized values of larger values will be automatically larger as well.
\end_layout

\begin_layout Standard
In an optimal clustering we obviously want to have compact clusters, which
 are as distant as possible.
 Thus the validity measurement is defined as the ratio of the intra and
 inter measure.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{validity}=\frac{\text{intra}}{\text{inter}}
\]

\end_inset


\end_layout

\begin_layout Standard
The optimal cluster count should posses the smallest validity.
 
\end_layout

\begin_layout Standard
The proposed algorithm of Siddheswar Ray and Rose H.
 Turi can be seen in algorithm 2.2.
 It starts with initialising every single data point into one cluster and
 using the average of each data point as cluster center (line 1).
 Repeatedly the variance of each data point will be calculated and added
 up, the sum of all points will be used as divisor (line 3).
 The cluster with the largest value will be split (line 4).
 Due to the occurring minimization of intra-cluster distance in k-means
 clustering, this cluster would most likely be split when increasing the
 cluster count.
 Before the process will be repeated, the normal k-means clustering is executed
 and the validity calculated according to the new calculated cluster centers
 (line 5).
 This processes is repeated until a self-assigned number of clusters 
\begin_inset Formula $k_{\text{max}}$
\end_inset

 is reached.
 From this follows that the basic k-means algorithm will be run 
\begin_inset Formula $k_{\text{max}}$
\end_inset

 times.
\end_layout

\begin_layout Standard
The clusters will be split, according to the old cluster center and with
 regard to the minimum and maximum of each attribute.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{i}^{'}=\left(z_{i1}-a_{1},z_{i2}-a_{2},z_{i3}-a_{3}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
z_{i}^{''}=\left(z_{i1}+a_{1},z_{i2}+a_{2},z_{i3}+a_{3}\right)
\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $z_{i}^{'}$
\end_inset

 and 
\begin_inset Formula $z_{i}^{''}$
\end_inset

 being the two new cluster centers, 
\begin_inset Formula $z_{i}$
\end_inset

 being the the old cluster centers with index 
\begin_inset Formula $1,2,3$
\end_inset

 for each attribute.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
a_{j}=\frac{z_{ij}-\max_{j}}{2}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\max_{j}$
\end_inset

 is the maximum value for the 
\begin_inset Formula $j$
\end_inset

-component.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Find the optimal cluster count algorithm
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {Initialise a single cluster, with the average of each attribute as
 cluster center}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat{}
\end_layout

\begin_layout Plain Layout


\backslash
State {calculate the variance of each attribute $
\backslash
sigma_{i}$ and add them up $
\backslash
sum_{i=1}^{I}
\backslash
frac{1}{I}
\backslash
sigma_{i}$ }
\end_layout

\begin_layout Plain Layout


\backslash
State {split the cluster centers with the biggest variance}
\end_layout

\begin_layout Plain Layout


\backslash
State {use the standard k-means algorithm and calculate the validity}
\end_layout

\begin_layout Plain Layout


\backslash
Until {a self-assinged limit $k_
\backslash
text{max}$ is reached}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Due to the larger inter-cluster distance, small cluster numbers tend to
 be selected more often.
 In synthetic images, with an actual perfect cluster count the calculated
 minimal validity will be the optimal cluster count.
 In natural images the best number of clusters is usually prefered.
 To overcome the effect of a large inter-cluster distance with a small k,
 the first local maximum in the validity measure needs to be found.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{val}(k-1)<\text{val}(k)>\text{val}(k+1)
\]

\end_inset


\end_layout

\begin_layout Standard
The adjusted best validity measure will be the smallest validity in between
 the range of 
\begin_inset Formula $\text{val}(k)$
\end_inset

 and 
\begin_inset Formula $\text{val}(k_{\max})$
\end_inset

.
\end_layout

\begin_layout Standard
It is important to notice that this algorithm is supposed for image segmentation
 in RGB-color space, although it can also be implemented on a different
 feature space as long as the attributes can be scaled properly.
\end_layout

\begin_layout Section
Color spaces
\end_layout

\begin_layout Standard
A color space is a specific combination of color channels which forms a
 reproducible representation of colors in both digital and analog representation
s.
 An image is only a spatially organized set of numbers, where pixels describe
 the particular combination of color channels at a specific position.
 A gray image for example is a 2d-array limited to a single color channel.
 The most used color space is the RGB-color space.
 It is based on the tristimulus theory of color in the human visual system.
 Its name describes the 3 used color channels; red, green and blue.
 This is similar to the three types of cones in the human eye which absorb
 the respective electromagnetic wavelengths.
 In normal 24-bit images, each channel is usually scaled to 0–255 for the
 common 1 byte per colour channel.
 Therefore it is important to notice is that the color channels overlap.
 A perceived blue item will have the highest peak in the blue channel, but
 it will also have milder components of red and green
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011,Lucchese_colorimage"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/rgb_cube.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A representation of the 3d RGB cube
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
The main problem with the RGB-colorspace in image processing is its non-linearit
y.
 Moving in a certain way in the cube might not produce a color that is perceptua
lly consistent with the change in each of the channels.
\end_layout

\begin_layout Standard
The HSV-color space is closer to the human idea of color, because it is
 easier to think of a color in terms of H(ue), S(aturation) and V(alue).
 The value determines the brightness.
 The color space can be represented in a 3d-hexagone, where the central
 vertical axis represents the Intensity.
 Hue is defined as an angle in the range 
\begin_inset Formula $[0,2\pi]$
\end_inset

 and Saturation is the depth or purity of the color, it is measured as a
 radial distance from the central axis
\begin_inset CommandInset citation
LatexCommand cite
key "Sural"

\end_inset

.
\end_layout

\begin_layout Standard
The HSV-color space is advantageous in comparison to the RGB-color space
 in color based image segmentation, because image objects are more consistently
 contained in the resulting hue field than in the channels of the RGB representa
tion.
 This applies in particular to changing light conditions
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset

.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/hsv_representation.png
	scale 45

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
A representation of the HSV colorspace cone
\begin_inset CommandInset citation
LatexCommand cite
key "ChrisSolomon2011"

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Both RGB and HSV spaces are however, not perceptually uniform; the distances
 among colors perceived by the human are not mirrored by similar distances
 between the points representing those colors in such spaces
\begin_inset CommandInset citation
LatexCommand cite
key "Lucchese_colorimage"

\end_inset

.
\end_layout

\begin_layout Chapter
Adaptive K-means clustering
\end_layout

\begin_layout Standard
One of the logical extensions of the k-means algorithm used for color segmentati
on seems to implement the algorithm not only on images, but on whole video
 sequences.
 The existing algorithms for determining the optimal cluster count could
 be transferred on whole videos, by simply processing them frame by frame.
 Usually the resulting processing time would prove unfit for most practical
 use if the algorithm is applied on each frame of the video.
 While the regular k-means computing time is feasible, at least if an iteration
 limit is implemented, the computing time for dynamic cluster count identificati
on as discussed in 2.4 is tremendous, due to the repeated use of the basic
 k-means algorithm.
 
\end_layout

\begin_layout Standard
Hence, the first task of this bachelor thesis is to find a way to adapt
 the identification of the optimal cluster number from images to video sequences.
 
\end_layout

\begin_layout Standard
Without further investigation the resulting cluster have only a limited
 application use and can only represent the gathered knowledge of a single
 frame.
 In order to include the information of the whole video it is necessary
 to compare the resulting clusters of each frame.
 A continuous occurring in several frames should eventually be recognized.
 
\end_layout

\begin_layout Standard
Thus, the second task of this bachelor thesis is to implement a similarity
 measurement for clusters to merge them over several frames.
 In order to distinguish the clusters which are calculated using the k-means
 algorithm in a single image and the clusters which are generated through
 merging clusters of a video sequence, the latter kind will be referred
 to as 
\begin_inset Quotes eld
\end_inset

super-clusters
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Section
Dynamic cluster count algorithm in video sequences
\end_layout

\begin_layout Standard
Due to color segmentation in video sequences and images being essentially
 the same problem, the proposed algorithm by Siddheswar Ray and Rose H.
 Turi, would also work in videos
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

 .Due to the assumption that we are only looking at continuous video sequences,
 calculating the optimal cluster count for each frame individually, without
 including any knowledge gained from the previous calculations, would result
 in redundant calculations for most videos.
 Thus the aim is to reduce the calcuation time, while maintaining the same
 results algorithm 2.2 would produce if applied on each frame individually.
\end_layout

\begin_layout Standard
Often the optimal cluster count will be unchanged from one frame to the
 subsequent one.
 The resulting cluster will only vary slightly, either due to an occurred
 movement or due to a change of the lightning condition.
 Hence it seems reasonable to look for an effective way to include the gained
 knowledge of the previous frames.
 One option would be to check whether cluster centers of the previous frame
 could be kept as initial center for the k-means algorithm of the current
 frame.
 
\end_layout

\begin_layout Standard
As described in 2.3 the measure to evaluate the number of clusters is the
 validity, its optimal value always falls on a local minimum in comparison
 to a higher/lower cluster count.
 Which means that if the cluster centers of the previous frame still constitute
 a local minima in the current frame it is likely that the optimal cluster
 count is unchanged.
 
\end_layout

\begin_layout Standard
Unfortunately there are two major problems with this conclusion.
 Even if the old cluster centers constitute a local minimum on the current
 frame it is not guaranteed that it is the optimal solution.
 As described in 2.3 the optimal cluster count for a synthetic image seems
 to be the global minima and in case of a real image it would be the smallest
 validity after the first local maxima.
 Neither for synthetic images, nor for natural images can be checked whether
 the current minimum constitutes the optimum without calculating the validity
 for each k.
 
\end_layout

\begin_layout Standard
Consider for example the validity chart in Fig 3.1.
 Searching for the minimal validity would result in only 2 clusters.
 As discussed in 2.3 the best validity in natural images would be at k =
 8, because it is the minmal value after the first local maximum.
 But if the previous frame would have had 13 clusters, the adapted algorithm
 would continue to work with those clusters, because k = 13 constitutes
 a local minimum.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/graph_validity.png
	scale 65

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of a validity chart
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Even if the optimal number of clusters in a frame would equal the used number
 of clusters in a former one, the old cluster centers might be unfit as
 initialization points for k-means clustering in the current frame.
 To get a good initialization point, the algorithm of Siddheswar Ray and
 Rose H.
 Turi puts the whole image into a single cluster at first.
 The mean of each pixel builds its cluster center.
 Continually the cluster with the highest variance is split into two parts.
 Thus using the old cluster centers as initialization points for k-means
 clustering implies the assumption, that each time a cluster had the highest
 variance in the previous frame, the same cluster would have the highest
 variance in the current frame as well.
 
\end_layout

\begin_layout Standard
Despite the occurring problems, using the local minima assumption seems
 to be a good indicator to either keep the old cluster centers as initialization
 points or start all over.
 The stated problems are expected to occure rarely, due to mostly small
 occurring changes when transitioning from one frame to another.
 The impact of identifying the wrong cluster count in a video sequence will
 be further discussed in the evaluation of this algorithm.
\begin_inset Foot
status open

\begin_layout Plain Layout
see 4.4 implementation in a video sequence
\end_layout

\end_inset


\end_layout

\begin_layout Standard
At the beginning of this algorithm, the normal algorithm 2.2 will be used
 on the first frame to get a good starting point to cluster the remaining
 frames.
 In each iteration of algorithm 2.2 the cluster centers for the current k
 have to be saved (line 2).
 This is necessary in order to check whether the old cluster centers still
 constitutes a local minima in the validity chart on the next frame.
 First the validity of the best cluster centers in the first frame has to
 be calculated on the current frame (line 4).
 As in all following steps as well, the adapted cluster centers for k have
 to be stored (line 5).
 To check whether this validity constitutes a local minimum, the validity
 for k+1 and k-1 is needed.
 To get this for k+1 the same process as previously described can be used
 and the cluster with the highest variance will be split (line 6).
 Afterwards the basic k-means algorithm is applied and the validity is calculate
d (line 7).
\begin_inset Foot
status open

\begin_layout Plain Layout
see 2.3 Optimal cluster count
\end_layout

\end_inset

 Unfortunately it is not possible to simply remerge two clusters, because
 there is no similar indicator as the variance for splitting, which defines
 the clusters who have previously belonged together.
 Instead for getting the validity for k-1 the corresponding cluster centers
 of the previous cycle has to be used as initialization point for k-means
 clustering (line 9), although this cluster centers have been generated
 using a previous frame.
 Therefore it is important to save all calculated cluster centers, because
 they might be used later.
 After running k-means clustering and calculating the variance it can finally
 be checked, if the validity for k consitutes a minimum (line 12).
\end_layout

\begin_layout Standard
If this is the case the described steps can simply be repeated on the next
 frame.
 Otherwise the old cluster center seem to be unoptimal and thus the whole
 algorithm 2.2 will be repeated on the current frame (line 15).
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {Split the video sequence into frames} 
\end_layout

\begin_layout Plain Layout


\backslash
State {Use algorithm 2.2 to find the optimal k for the first frame and save
 the cluster centers for each number of clusters}
\end_layout

\begin_layout Plain Layout


\backslash
Repeat{ for each frame}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use standard k-means with existing cluster centers of k and calculate
 the validity}
\end_layout

\begin_layout Plain Layout


\backslash
State {Save the new cluster centers for k}
\end_layout

\begin_layout Plain Layout


\backslash
State {Split the cluster with the highest variance}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use the k-means algorithm and calculate the validity for k+1}
\end_layout

\begin_layout Plain Layout


\backslash
State {Save the new cluster centers for k+1}
\end_layout

\begin_layout Plain Layout


\backslash
State {Get the cluster centers of k-1 of the previously stored iterations}
\end_layout

\begin_layout Plain Layout


\backslash
State {Use the k-means algorithm and calculate validity for k-1}
\end_layout

\begin_layout Plain Layout


\backslash
State {Save the new cluster centers for k-1}
\end_layout

\begin_layout Plain Layout


\backslash
If {validity of k-1 > validity of k <= validity of k+1}
\end_layout

\begin_layout Plain Layout


\backslash
State { 
\backslash
textbf{continue} }
\end_layout

\begin_layout Plain Layout


\backslash
Else 
\end_layout

\begin_layout Plain Layout


\backslash
State {Use algorithm 2.2 and save the cluster centers for each number of
 clusters}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
Until {all frames are processed}
\end_layout

\begin_layout Plain Layout


\backslash
State {Group the clusters into super-clusters according to a similarity
 measurement}
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
The adapted algorithm to find the optimal cluster count in video sequences
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This algorithm will save computational time in cost of accuracy.
 In some special cases it will provide non optimal solutions, this will
 further be outlined in chapter 4.
 
\end_layout

\begin_layout Section
Similarity measurement of clusters occurring over several frames
\end_layout

\begin_layout Standard
In order to find a suitable similarity measurement for comparing clusters,
 it is important to keep track of the goal.
 The fusion of several similar clusters into one super-cluster should finally
 provide information of the whole video.
 The basic k-means color segmentation algorithm as described in 2.2 is repeatedly
 used in 2.3, would ultimately provide only minimal information via the cluster
 centers.
 
\end_layout

\begin_layout Standard
For example, if only the Euclidean distance of each cluster center would
 be compared and the most similar ones would be merged, the gained information
 could be seen as color histogram of the whole video sequence.
 One improvement step is not only to include the color spaces, but also
 the size to compare clusters.
 Thus clusters which share a color with another cluster center but are ultimatel
y unconnected, might already be separated and don't share the same super-cluster.
 
\end_layout

\begin_layout Standard
Without including the coordinates in any way, clusters cannot include any
 information about shape and may contain disjointed areas.
 For example in Figure 3.2 the optimal cluster count so far would be determined
 as 2, because it only consists of 2 colors and a pure color segmentation
 algorithm is applied.
 One cluster contains the black background and the second one the red rectangles.
 To split clusters not only according to their color, but also according
 to their geometrical distinctness, the coordinates of each pixel need to
 be considered when calculating the clusters.
 If the geomatrical distinctness is considered, the optimal clustercount
 in Figure 3.2 changes from 2 to 3, because the rectangles are not connected.
\end_layout

\begin_layout Standard
There are several ways to include geometrical features, but it would be
 optimal if reasonable results could be achieved with the k-means clustering
 algorithm itself.
 The basic idea hereby is to extend the feature space from a 3d-vector which
 includes the color space, to a 5d-vector which also includes the XY-coordinates.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/beispiel.png

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Example of an image with optimal cluster count of 2 on pure color segmentation
 and optimal cluster count of 3 when including geomatrical features
\end_layout

\end_inset


\end_layout

\end_inset

A different approach to include geometrical knowledge is to detect shapes
 in the already separated clusters, created by the k-means color segmentation
 algorithm.
 The OpenCV library
\begin_inset CommandInset citation
LatexCommand cite
key "openCV_doc"

\end_inset

 already implements the necessary functions for doing so.
 First a canny algorithm will detect the edges of the respective cluster,
 before the openCV method 
\begin_inset Quotes eld
\end_inset

findContours(...)
\begin_inset Quotes erd
\end_inset

 will finally try to calculate the corresponding contours.
 Contours can be seen as boundaries, and in contrast to edges they form
 closed curvatures.
 If there are several contours convoluted in each other as for example seen
 in Figure 3.3, only the most outer one is relevant and will represent a
 cluster.
 In the case of the image in Figure 3.3 the only relevant contours are labeled
 from 0-2, because the remaining contours are all enclosed in contour 2.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\end_inset


\begin_inset Graphics
	filename images/hierarchy.png
	scale 70

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example for hierachy in edge detection
\begin_inset CommandInset citation
LatexCommand cite
key "openCV_doc_hiearch"

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Results and Evaluation
\end_layout

\begin_layout Section
Evaluation of the optimal cluster count
\end_layout

\begin_layout Subsection
On synthetic images
\end_layout

\begin_layout Standard
The results reported from Siddheswar Ray and Rose H.
 Turi 
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset

 on synthetic images described in 2.3, could mostly be verified.
 On very simple images as seen in Fig 4.1 the automatically specified cluster
 count matches the actual used colors.
 Notice that this section is only concerned about color segmentation.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Graphics
	filename images/beispiel.png
	scale 75

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/beispiel2.png
	scale 37.5

\end_inset


\begin_inset space ~
\end_inset


\begin_inset Graphics
	filename images/beispiel3.png

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated images with known used number of colours (2, 5, 4)
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Surprisingly the calculated optimal cluster count using the RGB color space
 and a maximal cluster count of 25 in Figure 4.2 was determined as 10 instead
 of the expected 5 clusters.
 This error occurs due to the different numbers of colors used in differing
 shapes.
 Each rectangle consists of only of one specific color, whereas the circle
 can be distinguished into several RGB-values.
 The core of the circle and everything in close distance has only one color
 value, but the closer the distance to the boundary the more the color changes
 in order to achieve an effect of anti-aliasing, this can be seen in Figure
 4.3.
 Anti-aliasing makes the rectangle shape of pixels on a computer display
 less visible for the human eye.
 In this specific case the circle consists of 49 different RGB values.
 Due to the relationship of inter cluster distance and intra cluster distance
 the circle is split into 5 different clusters.
 The conversion into HSV did not result in a calculated cluster count of
 5 either; instead it went up to 13 (keeping the Euclidean distance as distance
 measurement).
 As described in 2.4 the different nature of the RGB color space and HSV
 color space results in different distances in between colors.
 Many of the 49 RGB colors will probably share the same hue value, but can
 be further clustered according to the saturation and brightness.
 Therefore this results in different clusters in comparison to the RGB color
 space and with it to a rise of the calculated optimal cluster count.
\end_layout

\begin_layout Standard
Given that the used colors in a natural images are expected to be a lot
 more than 53, the performed clustering will never be on a comparable fine
 level.
 The decrease of the intra cluster distance would lead to a lower inter
 cluster distance and supposedly the validity would increase.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/circle.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{images/circle_HSV.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{converted into HSV} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{images/circle_anti_aliasing.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{zoomed in circle} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated image including a circle converted into HSV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Increasing the number of circles and adding more colors overall to testing
 images as for example seen in Figure 4.3, resulted in a correct computation
 of the cluster count in RGB color space.
 The particular image is built of 4564 RGB values and the right cluster
 count of 10 is calculated.
 Transferring this image into the HSV color space resulted in the computation
 of 10 as well.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/4564colors.jpg} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{images/colors_to_HSV.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{clustered in HSV} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.3
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{images/colors_toHSV2BGR.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{b) converted into RGB} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Simple generated image build of 4564 RGB values converted into HSV
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Subsection
On real images
\end_layout

\begin_layout Standard
Until now the cluster count was only tested on self-generated images with
 known optimal cluster count.
 On real images this is usually only roughly estimable.
\end_layout

\begin_layout Standard
The algorithm was tested clustering images of the Berkeley Segmentation
 Dataset
\begin_inset CommandInset citation
LatexCommand cite
key "Arbelaez2011"

\end_inset

 and provided satisfactory results.
 To evaluate the dynamic cluster count the clustered images, were compared
 to the images generated with a higher/lower number of clusters.
 These are also generated with algorithm 2.2.
 It increments the number of clusters succesively until 
\begin_inset Formula $k_{\max}$
\end_inset

 is reached, hence the images in the range from k = 2 to k = 
\begin_inset Formula $k_{\max}$
\end_inset

can be used for comparison purposes.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{images/128035.jpg} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/128035_rgb_8_opti
mal.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{calculated k = 8} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/128035_
rgb_6.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 6} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/128035_rgb_14.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 14} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
Gallery example from the Berkeley Database clustered in RGB-color space
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The calculated cluster count of 8 in Figure 4.4 is the first cluster count
 where, the red shirt builds its own cluster.
 It seems as in a smaller cluster counts the inter cluster distance is bigger.
 In k > 8 the intra cluster distance seems to be minimized but has only
 minimal visible impact, because of the higher inter cluster distance before.
 Thus k = 8 seem to be the right choice.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_4_optimal.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{calculated k = 4} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_5.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 5} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/2018_rg
b_10.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 10} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Snow shoes example from the Berkeley Database clustered in RGB-color space
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The calculated cluster count of 4 in Figure 4.5 seems to retain most key
 features of the image, the results seen in c) for k=3 seem to be similarly
 well.
 The cluster count of 10 seen in d) might be preferable due to the existence
 of a cluster solely for the snow shoes.
 The latter impression probably arises of our focus on the image center;
 but looking at the sky reveals that it has already been segmented into
 3 sections at this point.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rgb_6_optima
l.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{calculated k = 6} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rg
b_3.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/3063_rgb_8.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 8} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Airplane example from the Berkeley Database clustered in RGB-color space
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The calculated optimal cluster count of 6 in Figure 4.6 seems to be the most
 adequate cluster number, although k=3 seems to highlight the plane better.
 However, k-means clustering is an unsupervised algorithm without prior
 knowledge, hence the cluster count of 6 retains more information of the
 background as well.
\end_layout

\begin_layout Standard
Using the HSV-color space instead of the RGB-color space did not lead to
 considerably better results.
 Strikingly the calculated optimal cluster count was mostly higher in HSV
 as for example seen in Figure 4.7.
 Otherwise the same findings as in the RGB-color space could be made.
 Overall the comparison did not favor any color space.
 The results were subjectively examined on the same level.
 The determination of which color space to use, should depend on the final
 task of the clustering algorithm.
 Because the following work is rather on an abstract level than on implementing
 the algorithm on a particular task and because the underlying algorithm
 for determining the cluster count was originally proposed for the RGB color
 space, the latter one will be used in the evaluation of the dynamic cluster
 count on video sequences.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046.jpg
} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_rgb_4.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{calculated k = 4 (RGB)} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_hs
v_6.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{calculated k = 6 (HSV)} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/6046_hsv_6_to_rgb.
png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{c) converted into RGB} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of results in RGB and HSV color spaces
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Section
Implementation in a video sequence
\end_layout

\begin_layout Subsection
On synthetic video sequences
\end_layout

\begin_layout Standard
Implementing the dynamical cluster count as described in algorithm 3.1 into
 a simple synthetic video sequence revealed that the cluster count incremented
 correctly when necessary, but failed to detect required reductions of k.
\end_layout

\begin_layout Standard
Figure 4.8 shows an example of a video sequence.
 In image a) to d) the cluster count stays the same and is recognized correctly.
 The new appearance of a rectangle in cluster e) leads to a new cluster
 count calculation.
 In cluster g) the green rectangle is gone and a new cluster count calculation
 should be the result.
 Unfortunately the algorithm fails to identify the change and keeps the
 old cluster count.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.22
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample0.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.22
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample1.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.22
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample2.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.22
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample3.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.325
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=0.67
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample4.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 4}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.325
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=0.67
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample5.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 4}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.325
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=0.67
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/simple_VidExample6.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{k = 3}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout

\lang ngerman
A simple video sequence in which areas are moving out of the video
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
This and similar tests showed that as long as something is added to the
 scene, the variance calculation of previous runs for determining the cluster
 count will still be meaningful for the current frame.
 If the clusters are calculated with k-means using the cluster centers of
 the previous frame as initialization points, the generated clusters will
 have a higher variance if a new area is added to the scene.
 Thus the validity measure will usually decrease if the number of clusters
 is increased, this is the same principle used in algorithm 2.2.
 Even if the algorithm for identifying the optimal cluster count would have
 split clusters in a different way if run on the current image, the disparity
 can still be regulated.
 For the transformation from k to k+1, the k-means algorithm splits the
 cluster with the highest variance on the current image.
 In contrast the initialization points for k-1 are solely received via the
 calculation on previous frames.
 Therefore the calculations of the validity for k-1 needs to be improved.
 One possibility for doing so is to use the same procedure as k+1 received
 already.
 Instead of calculating the validity for k-1 immediately, the cluster centers
 for k-2 (if k>3) will be used as initialization points.
 The new clusters will be split once again as described in 2.3 and the arising
 cluster centers will be used to calculate the validity for k-1.
 Another improvement can be achieved, when the order of the validity checks
 is changed.
 The validity for k-1 will be checked first, the generated clusters will
 be split twice and used to calculate the validity for k and k+1.
\end_layout

\begin_layout Standard
With this slight modification the algorithm achieved the right cluster count
 results on all self-generated simple video sequences similar to Figure
 4.8 as long as the conditions remained constant.
 The considered cases included appearing and disappearing areas both solely
 and simultaneously.
 
\end_layout

\begin_layout Standard
However, adding blurring, noise or light effects to an image resulted most
 often in a different cluster count than before, indicating unstableness
 in real images on changing conditions.
 But the impact of these effects on simple images with only few features
 is found to be stronger and less subtle than in most real occurring condition
 changes seen in natural video sequences.
\end_layout

\begin_layout Standard
To actually compare the produced cluster centers over several frames, the
 generated cluster centers of the first frame were used as the first centers
 of 
\begin_inset Quotes eld
\end_inset

super-clusters
\begin_inset Quotes erd
\end_inset

 (=merged clusters of frames).
 On each iteration of the algorithm, after the optimal number of clusters
 has been identified, the new cluster centers are compared to the centers
 of existing super-clusters.
 For comparison the usual Euclidean color space distance and the Euclidean
 distance of the coordinate centers of the cluster centers and the super-cluster
s were calculated.
 In order to add them, they had to be normalized.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{color}=|v_{color\,1}-v_{color\,2}|
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{coord}=|v_{coord\,1}-v_{coord\,2}|
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{v1\,v2}=d_{color}+d_{coord}
\]

\end_inset


\end_layout

\begin_layout Standard
With 
\begin_inset Formula $v_{1}$
\end_inset

 being the normalized cluster center and 
\begin_inset Formula $v_{2}$
\end_inset

 being the normalized center of the super-cluster.
 
\begin_inset Formula $v_{color}$
\end_inset

 only includes the color information and 
\begin_inset Formula $v_{coord}$
\end_inset

 only includes the center coordinates.
\end_layout

\begin_layout Standard
If the sum of both distances of the closest super-cluster was smaller than
 a self-determined 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the cluster center belonged to the super-center.
 
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
d_{v1\,v2}<d_{max\cdot\delta}=\delta_{dis}
\]

\end_inset

In this case the center of the super-cluster had to be updated.
 Thus the old center of the super-cluster is simply replaced with the newest
 member.
 To get to a good 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the maximal possible distance has to be considered and scaled accordingly.
 An alternative approach is to add the center of the cluster to the center
 of the super-cluster and divide it by 2.
 This led to more stable results.
 As soon as one outlier appears the center is shifted in the wrong direction.
 Because it is likely that new clusters will not be assigned to the right
 super-cluster.
 Normally we expect clusters to move continuously in the same direction,
 hence the first method led mostly to better results.
\end_layout

\begin_layout Standard
Otherwise if the distance to the closest super-cluster was bigger than 
\begin_inset Formula $\delta_{dis}$
\end_inset

 the cluster center is not part of an existing supercluster and its values
 will be the initial values of a new super-cluster.
\end_layout

\begin_layout Standard
This method generated the right results for simple synthetic video sequences
 using a reasonable 
\begin_inset Formula $\delta$
\end_inset

.
 For example, the video sequence seen in Fig 4.8 
\begin_inset Formula $\sim0.06<\delta<0.6$
\end_inset

 produced right results.
 Overall 
\begin_inset Formula $\delta=0.15$
\end_inset

 was found to be a good threshold, a higher value for 
\begin_inset Formula $\delta$
\end_inset

 often resulted in putting several clusters of one frame into a single super-clu
ster.
\end_layout

\begin_layout Subsection
On real video sequences
\end_layout

\begin_layout Standard
To evaluate the performace of algorithm 3.1 its calculated adaptive cluster
 count was compared to the outcome produced by its predecessor algorithm
 developed by Ray and Rose H.
 Turi
\begin_inset Foot
status open

\begin_layout Plain Layout
algorithm 2.2
\end_layout

\end_inset

, where each frame was processed individually.
 This was done on video sequences of the Freiburg-Berkeley Motion Segmentation
 Dataset
\begin_inset CommandInset citation
LatexCommand cite
key "Ochs2014"

\end_inset

, one example consisting of only 19 frames can be seen in Figure 4.9.
\end_layout

\begin_layout Standard
The adapted and unadapted algorithms produced the same cluster count on
 most frames, however, the adapted algorithm tended to switch the cluster
 count less times than the unadapted one.
 
\begin_inset Note Note
status open

\begin_layout Plain Layout
In xy tested video sequences, the adapted algorithm produced the same cluster
 count in xy% of alltogether xy frames.
 
\end_layout

\end_inset

This outcome had to be expected, as described in 3.1 the adapted algorithm
 will not change the cluster count if the validity currently constitutes
 a local minima, whereas the unandapted algorithm will always go with the
 global minima.
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Wenn Zeit Tabelle und Abb auf eine Seite
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_01.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_02.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_03.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_04.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_05.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_06.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_07.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_08.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_09.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_10.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_11.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_12.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_13.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_14.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_15.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_16.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_17.jpg}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_18.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/cars1_19.jpg}}
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of a video sequence used for evaluation
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard

\lang english
\begin_inset Float table
wide false
sideways false
status open

\begin_layout Plain Layout

\lang english
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
centering 
\end_layout

\begin_layout Plain Layout


\backslash
begin{subtable}{.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{tabular}{ccl}
\end_layout

\begin_layout Plain Layout

	
\backslash
toprule
\end_layout

\begin_layout Plain Layout

	Frame & k & super-clusters 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
midrule
\end_layout

\begin_layout Plain Layout

	1-2 & 6 &  0 1 2 3 4 5 
\backslash

\backslash
 
\end_layout

\begin_layout Plain Layout

	3-11 & 5 & 0 2 1 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	12-16 & 5 & 0 1 2 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
rowcolor{LightCyan}17 & 6 & 0 3 2 4 1 5  
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
rowcolor{LightCyan}18-19 & 8 & 0 5 2 4 1 4 3 5
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout

	& & 8 super-clusters
\end_layout

\begin_layout Plain Layout

	
\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{results for Fig 4.9 using the unadapted  
\backslash
mbox{algorithm}}
\end_layout

\begin_layout Plain Layout


\backslash
end{subtable}%
\end_layout

\begin_layout Plain Layout


\backslash
begin{subtable}{.5
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout

	
\backslash
centering
\end_layout

\begin_layout Plain Layout

	
\backslash
begin{tabular}{ccl}
\end_layout

\begin_layout Plain Layout

	
\backslash
toprule
\end_layout

\begin_layout Plain Layout

	Frame & k & super-clusters 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
midrule
\end_layout

\begin_layout Plain Layout

	1-2 & 6 &  0 1 2 3 4 5 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	3-11 & 5 & 0 2 1 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	12-16 & 5 & 0 1 2 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
rowcolor{LightCyan}17 & 5 & 0 1 2 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
rowcolor{LightCyan}18-19 & 5 & 0 1 2 3 4 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout

	
\backslash
bottomrule
\end_layout

\begin_layout Plain Layout

	& & 7 super-clusters
\end_layout

\begin_layout Plain Layout

	
\backslash
end{tabular} 
\end_layout

\begin_layout Plain Layout

	
\backslash
caption{results for Fig 4.9 using the adapted  
\backslash
mbox{algorithm}}
\end_layout

\begin_layout Plain Layout


\backslash
end{subtable} 
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\lang english
\begin_inset Caption Standard

\begin_layout Plain Layout
The results produced on the video sequence of Figure 4.9 in RGB with 
\begin_inset Formula $\delta=0.2$
\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Table 4.1 shows the calculated number of clusters and the respective super-cluste
rs for the video sequence seen in Figure 4.9.
 The index on the list of super-clusters corresponds to the cluster of each
 frame which is assigned to the respective super-cluster.
 In this particular case the adapted algorithm produced only in 3 out of
 19 frames a different outcome.
\end_layout

\begin_layout Standard
The different results produced in the adapted and unadapted algorithm don't
 necessarily mean that the calculated cluster count of the adapted algorithm
 is worse.
 Sometimes it might be reasonable to keep the cluster count more stable.
 If the cluster count is mostly unchanged, the generated clusters are more
 similar and thus merge into fewer super-clusters.
 This might be useful for tracking the movement of an object.
 If the object is recognized in one of the clusters of the first frame,
 the corresponding super-cluster might ease the recognition in the following
 clusters.
 Figure 4.10 for example shows the super-cluster labeled as 4 in Table 4.1,
 where most key features of the car are visible.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{center}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_0.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_1.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_2.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_3.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_4.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_5.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_6.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_7.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_8.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_9.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_10.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_11.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_12.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_13.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_14.png}}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_15.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_15.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_17.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=0.22
\backslash
textwidth]{images/4_18.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
end{center}
\end_layout

\end_inset


\begin_inset Caption Standard

\begin_layout Plain Layout
The clusters, which are put into the super-cluster 4 in Table 4.1
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, it is unlikely that the features of an object are completely put
 into one cluster.
\end_layout

\begin_layout Standard
The super-clusters could also be used to compress the data size of the video
 sequence.
 The video sequence of Figure 4.9 could be encoded to only 7 colors when
 using the adapted algorithm.
 For other purposes it is hardly possible to rate the performance of this
 algorithm in reference to the super-clusters, due to the lack of similar
 scientific work.
 If the clusters would actually possess striking visual features the super-clust
ers could be evaluated further.
 Therefore it makes sense to try to include geometrical features into the
 segmentation process.
\end_layout

\begin_layout Section
Evaluation of k-means clustering with a 5d-feature vector
\end_layout

\begin_layout Standard
Using a 5d-feature vector, consisting of the color space and the coordinates
 promises two main advantages.
 Clustered regions would be closer to semantic knowledge, because regions
 with similar colors are already split and thus the results are more useful
 for comparing clusters over the cause of a video sequence.
 Furthermore after the k-means algorithm has clustered each frame separately,
 the whole outcome can build a new dataset, which then again could be clustered
 via k-means to fuse the clusters of each frame into super-clusters holding
 information of the whole video sequence.
 The requirement to do so are reliable and reasonable generated results
 when clustering single images.
 
\end_layout

\begin_layout Standard
To get reasonable images the 5d-feature vector has to be normalized first.
\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\text{5d-feature Vector: }\overrightarrow{v}=\begin{array}{c}
r\\
g\\
b\\
x\\
y
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Formula 
\[
\overrightarrow{v}_{normalized}=\begin{array}{c}
\frac{r}{255}\frac{1}{3}\\
\frac{g}{255}\frac{1}{3}\\
\frac{b}{255}\frac{1}{3}\\
\frac{x}{\max X}\frac{1}{2}\alpha\\
\frac{y}{\max Y}\frac{1}{2}\alpha
\end{array}
\]

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Formula $\alpha$
\end_inset

 is the scaling factor.
 Usually the color space will be seen as more important than the geometric
 features, so 
\begin_inset Formula $\alpha$
\end_inset

 will be close to zero.
 
\end_layout

\begin_layout Standard
The same normalization procedure should theoretically be applied on the
 variance calculation as well.
 Unfortunately due to the incoherent shape of the background, the cluster
 containing the background area had often the highest variance out of the
 calculated clusters.
 Figure 4.11 shows an example of this occurrence; the white area represents
 the not contained area of the specific cluster.
 While the algorithm gets the expected result for k=2 and 
\begin_inset Formula $\alpha=0.004$
\end_inset

 (a ratio of 250:1), it fails for k=3-5 and splits the background further.
\begin_inset Foot
status open

\begin_layout Plain Layout
Using the algorithm 2.2 to determine the optimal cluster count
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{/home/nilus/Dokumente/LyxBachelorarbeit/Bachelorarbeit/images/beispiel.png}
 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{source image} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 1} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters2.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 2} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters3.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{cluster 3} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of single clusters when splitting the wrong cluster using a 5d-feature
 vector
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
Ignoring the geometrical features while calculating the variance lead to
 better results in the case of Figure 4.11, but only by chance the rectangles
 were the first cluster in k=2.
 In order to split the right cluster a different measurement than the variance
 would be needed.
 Even if the problem of finding the right cluster to split is ignored and
 the right cluster is assigned manually, it didn't generate reasonable results.
 The major problem hereby is to find a scale of the geometric features to
 the color features.
 In some images this scale could be found, but did not result in equally
 good clusters on different images.
 The requirement to produce results on any image would be to assign the
 scale dynamically to each image.
 But for some images there might even exist no appropriate ratio of color
 features and geometrical features, which would lead to meaningful clusters.
 A potential instance of this will be further discussed in section 4.4.
 
\end_layout

\begin_layout Section
Evaluation of the alternative approach
\end_layout

\begin_layout Standard
Due to the inefficiency using a 5d-feature vector, especially with the problem
 of getting a right measure for the optimal cluster count, it seems easier
 to separate the splitting according to color features and the splitting
 according to geometrical features into two processes.
 Instead of clustering with a 5d-feature vector, the well performing 3d-vector
 including only the color space can be retained and each cluster might be
 further divided.
 
\end_layout

\begin_layout Standard
We only want to divide clusters with clear geometrical boundaries further.
 Hence if it is possible to draw several polygons without overlapping, where
 the area of the polygons is made up by the pixels of the clusters, the
 polygons will build new clusters.
\end_layout

\begin_layout Standard
This can be achieved using the openCV library
\begin_inset CommandInset citation
LatexCommand cite
key "openCV_doc"

\end_inset

.
\begin_inset Foot
status open

\begin_layout Plain Layout
see section 3.2
\end_layout

\end_inset

 Hereby one major problem needs to be considered.
 The cluster(s) which hold the color information of the background might
 lead to the same detected boundaries as the clusters which are actually
 surrounded by the background.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/beispiel_clusters_background.png} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=1
\backslash
textwidth]{images/contours0.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.2
\backslash
textwidth} 
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=1
\backslash
textwidth]{images/contours1.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{} 
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example images for the occurring background problem when calculating boundaries
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The first image of Fig 4.12 shows the image which will be clustered.
 This will result in two clusters, when determining the optimal cluster
 count for color segmentation.
 The first one will only hold the two red rectangles, while the second one
 will hold the background.
 The cluster containing the background can be seen in b).
 The last two images c) and d) show the calculated boundaries.
 Unfortunately these boundaries can be calculated using any of the two clusters.
 Hence if adding the calculated polygons of each cluster to the number of
 cluster centers, the optimal cluster count would be determined as 4 instead
 of 3.
 Thus the calculated polygons should only increase the cluster count if
 the comprised area is filled of the pixels which are part of the cluster
 used for calculating it.
 This check needs to be implemented in the algorithm.
 
\end_layout

\begin_layout Standard
Furthermore cluster centers should also include coordinates in order to
 get coherent clusters.
 In each iteration of the basic k-means algorithm, the mean of the coordinates
 of each updated cluster will form the cluster center together with the
 corresponding color features.
 
\end_layout

\begin_layout Standard
When splitting the cluster further using the method described in 2.4, the
 new cluster centers will be built up of the same color feature but will
 be separated according to the new mean of the coordinates of each polygon.
\end_layout

\begin_layout Standard
\begin_inset Float algorithm
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{algorithmic}[1]
\end_layout

\begin_layout Plain Layout


\backslash
State {calculate the mean of the coordinates of each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
State {update the cluster center including the coordinate information}
\end_layout

\begin_layout Plain Layout


\backslash
State {detect the (outer) boundaries of each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
For {each cluster}
\end_layout

\begin_layout Plain Layout


\backslash
If {Several polygons are detected and the pixels inside the polygons are
 part of the current cluster }
\end_layout

\begin_layout Plain Layout


\backslash
State {Delete the old cluster center of this cluster center}
\end_layout

\begin_layout Plain Layout


\backslash
State {Calculate the mean of the coordinates inside the boundary}
\end_layout

\begin_layout Plain Layout


\backslash
State {Built new cluster centers according to the calculated coordinates
 and the old color feature}
\end_layout

\begin_layout Plain Layout


\backslash
EndIf
\end_layout

\begin_layout Plain Layout


\backslash
EndFor
\end_layout

\begin_layout Plain Layout


\backslash
end{algorithmic}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Find geomatrical features of clusters
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
One of the advantages of the k-means algorithm is, that each pixel is assigned
 to the corresponding cluster center.
 The assignment could be done in different ways.
 Because the splitting of the clusters happens according to the calculated
 boundaries, it seems logical to check whether the pixels of the original
 cluster lie inside the calculated polygon and assign them accordingly.
 Alternatively the calculated cluster centers could be used as starting
 points for k-means clustering with either the 5d-vector of section 4.3 or
 using a 2d-vector consisting of the coordinates on the particular cluster.
\end_layout

\begin_layout Standard
Both assignment methods have some flaws, illustrated in 4.13.
 The created boundaries are not completely accurate, hence some pixels are
 not inside the polygon and will fall through the first method as seen in
 b).
 The second method doesn't consider boundaries at all, the k-means algorithm
 will simply check which pixel is on the shortest distance to the specific
 cluster.
 Adjusting the scale value 
\begin_inset Formula $\alpha$
\end_inset

 did not lead to the desired result and only adjusted distribution of the
 clusters slightly.
 The areas are too close together.
 Either the pixel distance, or the colors are required to be further divided
 in order to get correct results.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{1
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
centering
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=0.5
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/example_alt.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Source image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame{
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/example_altCluster.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{flaws via polygon check}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/finalK_12cluster_9.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{flaws via k-means}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Comparison of boundary cluster assignment and k-means
\end_layout

\end_inset


\end_layout

\end_inset

On simpler images as for example seen in Figure 4.1 both methods work fine
 and lead to the expected results.
 Overall, the method of checking whether a pixel lies within the calculated
 polygon seems to get closer to the expected results.
 The problem of assigning only few pixels to the wrong cluster could easily
 be solved.
 For example by implementing a noise filter.
 
\end_layout

\begin_layout Standard
On natural images however the described method didn't lead to an increased
 cluster count.
 In all tested images the contour detection failed to find useful polygons.
 Despite using a nearly optimal binary image in Figure 4.14, the resulting
 contours are not completely aligned.
 Printing all contours in one image shows the potential and might indicate
 how an improved detecting algorithm will improve the results.
 
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_binary.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Binary image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_single_contour.png}} 
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Best calculated contour}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.31
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1.1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/3063_all_contours.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{All contours in one image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Example of a flawed boundary detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Standard
The source image of Figure 4.15 presents two snowshoes.
 The goal in segmenting this image would be to split the particular cluster
 so that one features the left snowshoe and one features the right one.
 Unfortunately no fitting polygon could be calculated and the clusters remained
 unchanged.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/2018_binary.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{Binary image of interesting cluster}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\begin_layout Plain Layout


\backslash
begin{subfigure}[c]{0.5
\backslash
textwidth}
\end_layout

\begin_layout Plain Layout


\backslash
frame {
\backslash
includegraphics[width=1
\backslash
textwidth]
\end_layout

\begin_layout Plain Layout

{images/2018_contours.png}}
\end_layout

\begin_layout Plain Layout


\backslash
subcaption{All resulting contours in one image}
\end_layout

\begin_layout Plain Layout


\backslash
end{subfigure}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
Second example of a flawed boundary detection
\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Discussion and conclusion
\end_layout

\begin_layout Standard
Testing the described algorithm by Ray and Rose H.
 Turi on images verified the formerly reported results.
 Although some flaws need to be considered before using it.
 On very simplistic images the calculated cluster count will separate the
 image into too many clusters due to the possible reduction of the intra
 cluster distance.
 Besides this, it should be known beforehand whether the investigated image
 will be a synthetic or a real one.
 Usually this should be no problem and is no new finding, because it is
 already stated in the original article.
\begin_inset CommandInset citation
LatexCommand cite
key "Ray1999"

\end_inset


\end_layout

\begin_layout Standard
Adapting the algorithm to generate an adaptive cluster count on video sequences
 proved to work well on synthetic video sequences.
 On natural video sequences the results were satisfactory but did not always
 produce identical results in comparison to the independent calculated ones.
 Due to the high computation time, the effective use of this algorithm would
 require some further improvements for most of the possible tasks.
 Even if the current cluster count of a frame in a video sequence constitutes
 a local minimum in the next frame the basic k-mean algorithm has to be
 repeated 4 times.
 Otherwise the basic k-means algorithm will be repeated until 
\begin_inset Formula $k_{\max}$
\end_inset

 is reached.
 
\end_layout

\begin_layout Standard
The improvements should be tailored to the final task.
 For example, one idea for object-tracking would be to recalculate the cluster
 count only if the object has been lost.
 In addition the algorithm could implement multi-threading to improve the
 calculation time.
\end_layout

\begin_layout Standard
Creating super-clusters which include color- and coordinate information,
 by comparison of cluster center over several frames, provides knowledge
 of the movement and continuity of existing clusters.
 The information yield and specification of a good threshold 
\begin_inset Formula $\delta_{dis}$
\end_inset

 or even the suggested procedure for creating super-clusters in general
 can only be properly evaluated if the generated clusters are closer to
 semantic knowledge.
 This could be achieved by including more features in clustering than just
 the color information.
 The attempt of including geometric features via a 5d-feature vector while
 retaining the basic k-means algorithm did not lead to improved results.
 The main problem was to find a working ratio of the colors and coordinates,
 this ratio should furthermore be dynamic to be universal applicable.
 On some images the 5d-feature vectors did not deliver the desired outcome
 independent on the scaling ratio.
 This was probably caused by one of the big flaws of k-means clustering,
 it can only produce spherically formed clusters.
 This is especially problematic when the coordinates are included in the
 clustering process.
 In this cases other clustering methods as for example mean-shift would
 produce better results.
\end_layout

\begin_layout Standard
The alternative approach combined the region based image segmentation of
 k-means clustering with a boundary detection approach.
 Although the splitting of clusters did ultimately not work in real images,
 the found edges in single clusters showed some promise.
 The next step would be to include actual semantic knowledge in order to
 find objects or features, and create clusters solely for them.
\end_layout

\begin_layout Standard
The concept of super-clusters seemed to work quite well and merged similar
 clusters correctly.
 But besides data compression, no other field of use could be tested in
 this thesis.
 However, if semantic knowledge could actually be implemented in the clustering
 process, the serial identity of clusters in video sequences would drastically
 increase and therefore also the fundamental suitability of super-clusters.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "../bibtex-daten/bachelorarbeit-info"
options "unsrt"

\end_inset


\end_layout

\end_body
\end_document
